# 嵌入元數據

![](images/img_45.png)

## 說明

1. 這是官方在 `2024/04/25` 所發佈的 [官方教程](https://haystack.deepset.ai/tutorials/39_embedding_metadata_for_improved_retrieval)。

2. 使用的組件包含：`InMemoryDocumentStore`、`InMemoryEmbeddingRetriever`、`SentenceTransformersDocumentEmbedder`、`SentenceTransformersTextEmbedder`。

3. 將文檔索引到文檔存儲中時可有兩種選擇：一是 `嵌入文檔的文本`、二是 `嵌入文本和一些有意義的元數據`，在某些情況下，將 `有意義的元數據` 與文檔內容一起嵌入可改進檢索效果。

4. 這個範例的目標就是在索引文檔時 `嵌入元數據信息`，這可改進檢索效果，對於哪種類型的元數據適用當前所以需視狀況，此例中演示嵌入 `title` 元數據字段為嵌入模型提供良好的上下文，實作上將從維基百科獲取不同頁面，並將其與元數據（包括標題和 URL）一起索引到 `InMemoryDocumentStore` 中。

### 設置

#### 準備 Colab 環境
1. 在 Colab 中啟用 GPU 運行時。
2. 將日誌級別設置為 INFO。
3. 安裝 Haystack。

使用以下命令安裝 Haystack 2.0 和其他所需包：
```bash
pip install haystack-ai wikipedia sentence-transformers
```

#### 啟用遙測
知道您正在使用本教程有助於我們決定在哪些方面投入更多努力以改進產品，但您始終可以通過註釋掉以下行來選擇退出。詳情請參見遙測相關信息。
```python
from haystack.telemetry import tutorial_running
tutorial_running(39)
```

### 將文檔與元數據一起索引

創建一個管道，將小型示例數據集存儲在 `InMemoryDocumentStore` 中，並附加嵌入。將使用 `SentenceTransformersDocumentEmbedder` 生成文檔的嵌入，並將其寫入文檔存儲。

#### 代碼逐行註解
```python
from haystack.components.embedders import SentenceTransformersTextEmbedder

# 創建嵌入器，並指定要嵌入的元數據字段
embedder = SentenceTransformersDocumentEmbedder(meta_fields_to_embed=["url"])

from haystack import Pipeline
from haystack.components.preprocessors import DocumentCleaner, DocumentSplitter
from haystack.components.embedders import SentenceTransformersDocumentEmbedder
from haystack.components.writers import DocumentWriter
from haystack.document_stores.types import DuplicatePolicy
from haystack.utils import ComponentDevice

# 定義一個輔助函數來創建索引管道
def create_indexing_pipeline(document_store, metadata_fields_to_embed=None):
    document_cleaner = DocumentCleaner()  # 創建文檔清理器
    document_splitter = DocumentSplitter(split_by="sentence", split_length=2)  # 創建文檔分割器，按句子分割
    document_embedder = SentenceTransformersDocumentEmbedder(
        model="thenlper/gte-large", meta_fields_to_embed=metadata_fields_to_embed
    )  # 創建文檔嵌入器，並指定要嵌入的元數據字段
    document_writer = DocumentWriter(document_store=document_store, policy=DuplicatePolicy.OVERWRITE)  # 創建文檔寫入器，使用覆寫策略

    indexing_pipeline = Pipeline()  # 創建管道
    indexing_pipeline.add_component("cleaner", document_cleaner)  # 添加文檔清理器
    indexing_pipeline.add_component("splitter", document_splitter)  # 添加文檔分割器
    indexing_pipeline.add_component("embedder", document_embedder)  # 添加文檔嵌入器
    indexing_pipeline.add_component("writer", document_writer)  # 添加文檔寫入器

    # 連接管道組件
    indexing_pipeline.connect("cleaner", "splitter")
    indexing_pipeline.connect("splitter", "embedder")
    indexing_pipeline.connect("embedder", "writer")

    return indexing_pipeline  # 返回配置好的管道
```

接下來，我們可以從各種維基百科文章中索引文檔。我們將創建兩個索引管道：
- `indexing_pipeline`：僅索引文檔的內容，將這些文檔索引到 `document_store` 中。
- `indexing_with_metadata_pipeline`：將元數據字段與文檔內容一起索引，將這些文檔索引到 `document_store_with_embedded_metadata` 中。

```python
import wikipedia
from haystack import Document
from haystack.document_stores.in_memory import InMemoryDocumentStore

# 定義需要檢索的樂隊名稱
some_bands = """The Beatles,The Cure""".split(",")

raw_docs = []

# 從維基百科獲取每個樂隊的頁面，並創建文檔
for title in some_bands:
    page = wikipedia.page(title=title, auto_suggest=False)
    doc = Document(content=page.content, meta={"title": page.title, "url": page.url})
    raw_docs.append(doc)  # 將創建的文檔添加到列表中

# 創建內存文檔存儲
document_store = InMemoryDocumentStore(embedding_similarity_function="cosine")
document_store_with_embedded_metadata = InMemoryDocumentStore(embedding_similarity_function="cosine")

# 創建僅索引內容的管道
indexing_pipeline = create_indexing_pipeline(document_store=document_store)

# 創建索引內容和元數據的管道
indexing_with_metadata_pipeline = create_indexing_pipeline(
    document_store=document_store_with_embedded_metadata, metadata_fields_to_embed=["title"]
)

# 執行管道以索引文檔
indexing_pipeline.run({"cleaner": {"documents": raw_docs}})
indexing_with_metadata_pipeline.run({"cleaner": {"documents": raw_docs}})
```

### 比較有無嵌入元數據的檢索效果

最後一步，我們將創建一個檢索管道，該管道將包含兩個檢索器：
- `retriever`：從未嵌入元數據的 `document_store` 中檢索。
- `retriever_with_embeddings`：從嵌入了元數據的 `document_store_with_embedded_metadata` 中檢索。

我們將比較這兩個檢索器的結果，看看嵌入元數據是否有助於檢索。

```python
from haystack.components.embedders import SentenceTransformersTextEmbedder
from haystack.components.retrievers.in_memory import InMemoryEmbeddingRetriever

# 創建檢索管道
retrieval_pipeline = Pipeline()
retrieval_pipeline.add_component("text_embedder", SentenceTransformersTextEmbedder(model="thenlper/gte-large"))
retrieval_pipeline.add_component(
    "retriever", InMemoryEmbeddingRetriever(document_store=document_store, scale_score=False, top_k=3)
)
retrieval_pipeline.add_component(
    "retriever_with_embeddings",
    InMemoryEmbeddingRetriever(document_store=document_store_with_embedded_metadata, scale_score=False, top_k=3),
)

# 連接檢索管道組件
retrieval_pipeline.connect("text_embedder", "retriever")
retrieval_pipeline.connect("text_embedder", "retriever_with_embeddings")

# 執行檢索並比較結果
result = retrieval_pipeline.run({"text_embedder": {"text": "Have the Beatles ever been to Bangor?"}})

print("Retriever Results:\n")
for doc in result["retriever"]["documents"]:
    print(doc)

print("Retriever with Embeddings Results:\n")
for doc in result["retriever_with_embeddings"]["documents"]:
    print(doc)
```

### 實務上的應用與拓展說明

在實務中，嵌入元數據與文本的檢索技術具有廣泛的應用：

1. 提高精確度：嵌入元數據可以在不明確查詢時，根據上下文提供更多的信息。例如，使用電子商務平台時，使用商品名稱、分類等元數據可以提高搜索的相關性。
  
2. 上下文檢索：在法律文件或技術文檔中，元數據如文檔標題、發佈日期等可以用來提供更豐富的上下文，從

而提升檢索質量。

3. 個性化推薦：在推薦系統中，元數據如用戶喜好、過往行為記錄等，能幫助系統提供更準確的推薦結果。

4. 知識管理：在企業的知識管理系統中，將文件的作者、部門、日期等元數據嵌入，可以快速檢索到相關文件，提高工作效率。

這些應用表明，嵌入元數據的技術不僅可以提升檢索質量，還可以擴展到各種需要精確搜索和個性化推薦的領域。

---

希望這些說明能夠幫助您更好地理解和應用嵌入元數據技術！如果有任何問題或需要更詳細的解釋，請隨時提出。