# Stramlit + ChatBot

_這是一個完整的專案，結合 `Streamlit`、`Neo4j`、`LangChain`、`Docker` 等技術，可在本地、Codespace、Streamlit 服務器上運行。_

<br>

## 說明

1. 這個筆記是基於官方的 [GraphAcademy 教程](https://graphacademy.neo4j.com/courses/llm-chatbot-python/1-project-setup/) 所進行的拓展。

    ![](images/img_01.png)

<br>

2. 官方教程有部分不清楚之處，這個筆記進行了實作並詳細說明。

<br>

3. 範例中的腳本可參考 [GitHub](https://github.com/neo4j-graphacademy/llm-chatbot-python?tab=readme-ov-file)，在操作中也會透過 `Git` 指令克隆這個倉庫。

<br>

4. 相關參考資料眾多，如 [LangChain 官方文件 - Neo4j Vector Index](https://python.langchain.com/v0.1/docs/integrations/vectorstores/neo4jvector/)、 [neo4j 官方文件 － Vector search indexes](https://neo4j.com/docs/cypher-manual/current/indexes/semantic-indexes/vector-indexes/)。

<br>

## 查詢 Python 版本

1. 檢查 Python 版本：因為專案會使用 `Langchain` 模組，但是模組目前不支援 `Python 3.12` 以上版本，所以開始進行前，請確認本機當前 Python 的版本號。

    ```bash
    python --version
    ```

    ![img](images/img_55.png)

<br>

2. 由於教程中使用的是 `3.11`，所以本筆記也將採用相同版本，首先先查詢 `3.11` 所在何處。

    ```bash
    which python3.11
    ```

<br>

3. 結果會顯示位於 `/usr/local/bin/python3.11`，但這存放的 `符號鏈接`，而非真實路徑。

    ![](images/img_90.png)

<br>

4. 透過 `ls -l` 可查看 `符號鏈接` 的目標位置。

    ```bash
    ls -l /usr/local/bin/python3.11
    ```

    ![](images/img_91.png)

<br>

5. 透過這個路徑進行版本查詢，確認路徑無誤。

    ```bash
    /Library/Frameworks/Python.framework/Versions/3.11/bin/python3.11 --version
    ```

    ![](images/img_92.png)

<br>

## 建立虛擬環境

1. 進入自訂用於管理 Python 虛擬環境的資料夾中建立虛擬環境，這裡示範的路徑是 `~/Documents/PythonVenv`。

    ```bash
    cd ~/Documents/PythonVenv && /Library/Frameworks/Python.framework/Versions/3.11/bin/python3.11 -m venv envllmChatBot
    ```

<br>

2. 編輯環境參數。

    ```bash
    nano ~/.zshrc
    ```
    
    _或在 VSCode 中編輯_
    
    ```bash
    code ~/.zshrc
    ```

<br>

3. 在 `.zshrc` 文件中加入以下代碼，通常寫在最下方即可，然後透過組合鍵將文件儲存 `control+o` 並退出 `control+x`。

    ```bash
    source /Users/samhsiao/Documents/PythonVenv/envllmChatBot/bin/activate
    ```

<br>

4. 啟動虛擬環境。

    ```bash
    source ~/.zshrc
    ```

<br>

## 建立專案

1. 進入要存放專案的資料夾中，這裡示範存放在桌面，然後下載 git，並進入下載的資料夾。

    ```bash
    cd ~/Desktop && git clone https://github.com/neo4j-graphacademy/llm-chatbot-python && cd llm-chatbot-python
    ```

<br>

2. 透過指令查看 `requirements.txt` 文件中預設了哪些模組，預設包含了五個模組。

    ```bash
    cat requirements.txt
    ```

    ![](images/img_56.png)

<br>

3. 接下來透過指令安裝 `requirements.txt` 文件中指定的模組與對應的版本；但文件缺乏了專案所需的兩個套件，這裡示範使用指令 `echo` 來添加套件再安裝。

    ```bash
    echo -e "langchainhub\nlangchain_community" >> requirements.txt && pip install -r requirements.txt
    ```

<br>

4. 出現黃色錯誤訊息，無論是提示更新或警告有更新錯誤，基本上是不會影響套件安裝，但可手動更新。

    ![](images/img_93.png)

    _更新指令_

    ```bash
    python -m pip uninstall pip
    ```

<br>

5. 可再次確認 `requirements.txt` 的內容。

    ```bash
    cat requirements.txt
    ```

    _結果如下_

    ```txt
    langchain
    openai
    langchain_openai
    neo4j-driver
    streamlit
    langchainhub
    langchain_community
    ```

<br>

6. _特別說明_，由於後續會建立容器，在這裡先行寫入文件中可免去在建立容器時，還需在 `devcontainer.json` 文件中添加設置指令的麻煩。

<br>

## 啟動專案

1. 嘗試運行主腳本 `bot.py`。

    ```bash
    streamlit run bot.py
    ```

    ![](images/img_94.png)

<br>

2. 當前的機器人只會回應相同訊息。

    ![](images/img_02.png)

<br>

3. 先使用組合鍵 `control+c` 退出運行，然後運行以下指令開啟 VSCode 並重新啟動服務；這樣做並無其他目的，只是為了確保是在專案資料夾中開啟 VSCode，是一個開發上的習慣而已。

    ```bash
    code . && streamlit run bot.py
    ```

<br>

4. 開啟主腳本 `bot.py`，可見到代碼中很多標記語法 `# tag::`、`# end::` 或多行註解，這些語法主要用於說明或文檔生成工具、代碼片段提取工具、教程管理系統等，在這裏並無作用，可自行刪除。

    ![](images/img_95.png)

<br>

5. 若在 VSCode 中有使用 `Flake8` 等優化插件，可透過修改 `settings.json` 文件來設定，在專案根目錄內建立資料夾 `.vscode` 然後新增文件後寫入以下設定值。

    ```json
    {
        // flake8 長度
        "flake8.args": [
            // 取消長度
            "--max-line-length=200",
            // 取消首行必須是 import 的規定
            // 取消長度限制
            "--ignore=E402, E501"
        ],
    }
    ```

<br>

## 設定文件

1. 進入 [OpenAI 官網](platform.openai.com) 取得 API Key，這部分將在其他章節說明。

<br>

2. 在敏感資訊部分，一般情況會使用 `dotenv` 處理，而這個專案因為使用了 `Streamlit` 框架，故可使用框架內建的 `st.secrets[]` 進行設定，因為教程以建立了資料夾 `.streamlit`，所以新增設定文件即可；_補充說明_，資料夾中有一個文件 `.gitkeep`，故名可思議，這是一種在 Git 倉庫中保留空白目錄的常見約定方案，所以建立了 `secrets.toml` 文件之後可予以刪除。

   ```bash
   touch .streamlit/secrets.toml && rm -rf .gitkeep
   ```

<br>

3. 在專案中，後續會使用到 `OpenAI API` 以及 `Neo4J` 兩項服務的密鑰或憑證，這裡先將 `變數` 寫入，`值` 的部分在後續的操作中會再說明；_特別注意_，模組 `OpenAI` 內建會讀取環境參數中的 `OPENAI_API_KEY`，故這裡不要變更這個變數名稱，避免後續發生混淆或衝突。

    ```json
    OPENAI_API_KEY = "sk-"
    OPENAI_MODEL = "gpt-4-turbo"

    NEO4J_URI = "bolt://34.201.131.176:7687"
    NEO4J_USERNAME = "neo4j"
    NEO4J_PASSWORD = "oxides-winch-controls"
    ```

<br>

4. 關於模型介紹可閱讀 [官網](https://platform.openai.com/docs/models/models) 說明，_特別注意_，要填入的 `模型代號` 會在下方的說明中的 `Model`，而不是 `Models overview` 中的 `Model`。

   _這是說明_

   ![](images/img_46.png)

   _這是代號_

   ![](images/img_47.png)

<br>

4. 範例中已有 `.gitignore` 文件，並已寫入部分項目如下。

   ```json
   __pycache__
   .streamlit/secrets.toml
   .env
   .DS_Store
   ```

<br>

5. 在這個專案中並未使用 `.env`，這裡僅簡單說明 `.env` 與 `secrets.toml` 的差異，其中 `.env` 屬於一般文件而非腳本，所以字串部分是 _不需要加上引號的，等號兩側也無需間隔_，若是加上間隔或引號亦無妨，這與腳本文件 `secrets.toml` 是不同的格式，要特別注意。

   ```json
   OPENAI_API_KEY=sk-...
   OPENAI_MODEL=gpt-4-turbo
   ```

<br>

6. 若要使用 `dotenv` 則需安裝套件。

   ```bash
   pip install python-dotenv
   ```

<br>

## 腳本改寫

1. 主腳本 `bot.py`：初步修改時，可將瀏覽器頁籤改為自己的名稱如 `柱子`，另外也可把初次啟動的歡迎詞更改為 `哈囉，這是初次啟動，請問需要什麼服務？`。

    ```python
    import streamlit as st
    # 從自訂模組中導入函數
    from utils import write_message
    # 設定瀏覽器頁籤及圖標
    st.set_page_config("柱子", page_icon=":movie_camera:")

    if "messages" not in st.session_state:
        st.session_state.messages = [
            {
                "role": "assistant",
                "content": "哈囉，這是初次啟動，請問需要什麼服務？",
            },
        ]


    def handle_submit(message):
        # 提交時，會先顯示這個字串
        with st.spinner("讓我思考一下..."):
            from time import sleep

            sleep(1)
            write_message("assistant", message)


    for message in st.session_state.messages:
        write_message(message["role"], message["content"], save=False)

    # 假如用戶輸入了訊息
    if prompt := st.chat_input("怎麼了？有話就說吧～"):
        write_message("user", prompt)
        handle_submit(prompt)

    ```

<br>

2. 在主腳本中載入了模組 `utils.py`，所以這裡也可進行查看，這腳本無實質修改，僅刪除無謂的註解與標籤，這裡不再贅述；截至目前，機器人仍只會重複用戶對話。

    ```python
    import streamlit as st


    # 自訂一個寫入訊息的函數，參數有：角色、內容，並預設會儲存
    def write_message(role, content, save=True):
        # 儲存
        if save:
            # 依據傳入的角色將訊息寫入 session_state
            st.session_state.messages.append({
                "role": role, "content": content
            })
        with st.chat_message(role):
            # 依據角色，將對話顯示在客戶端或是服務端
            st.markdown(content)

    ```

<br>

## 建立 LLM 實體

1. `llm.py`：這個腳本主要是讀取了 `OpenAI API` 的相關設定，按範例預設即可。

   ```python
    import streamlit as st
    from langchain_openai import ChatOpenAI

    # 建立 ChatOpenAI 實體
    llm = ChatOpenAI(
        openai_api_key=st.secrets["OPENAI_API_KEY"],
        model=st.secrets["OPENAI_MODEL"],
    )
    from langchain_openai import OpenAIEmbeddings

    # OpenAIEmbeddings 是用來生成和處理嵌入向量（embeddings）
    # 這些嵌入向量是從使用 OpenAI 模型（如 GPT-4）生成的文本中獲取的
    embeddings = OpenAIEmbeddings(
        openai_api_key=st.secrets["OPENAI_API_KEY"]
    )

   ```

<br>

2. 補充說明，在 `llm.py` 中的 `embeddings = OpenAIEmbeddings(openai_api_key=OPENAI_API_KEY)` 代碼設置將用於在 `vector.py` 中導入並設置向量索引。

<br>

3. _特別補充_，教程裡說到要使用 `向量搜尋索引` 還需要建立 `OpenAIEmbeddings` 模型的實例，`Langchain` 將使用它來建立使用者輸入的嵌入，該嵌入將用於使用 Neo4j 的向量索引來尋找類似文件。

    ![](images/img_87.png)

<br>

## Neo4j Sandbox

_接下來需要使用資料庫來進行示範，所以建立 Neo4j 的沙箱來展示。_

<br>

1. 進入 [Neo4j Sandbox](https://sandbox.neo4j.com/onboarding)，進入後點擊 `Next`。

   ![](images/img_05.png)

<br>

2. 任意輸入一些基本資訊，然後點擊 `Complete` 完成，即便不是第一次登入也都要重複這個步驟。

   ![](images/img_03.png)

<br>

3. 點擊名稱 `Recommendations` 可展開，切換到 `Connection details` 頁籤，相關需要寫入 `secrets.toml` 文件的資訊都在這。

    ![](images/img_96.png)

<br>

4. 若想嘗是透過腳本連線資料庫，可切換到 `Connection via drivers`，然後點擊 `Python`，使用下方腳本中的 `URL`、`username`、`password` 等訊息編寫腳本，或直接複製腳本運行。

   ![](images/img_04.png)

<br>

5. 點擊 `Open` 預設會開啟 `Neo4j Browser`，另外有可選擇 `Open with Bloom` 或 `Open with NEuler` 等工具。

   ![](images/img_57.png)

<br>

6. 預設會使用 `neo4j+s` 連線，這與連線沙箱的 `URL` 是不同的。

   ![](images/img_84.png)

<br>

7. `Connect URL` 使用預設，切換到 `Username / Password`，貼上前面複製的密碼，接著點擊連線 `Connect`。

   ![](images/img_58.png)

<br>

8. 若連線資訊正確，便會進入連線畫面。

   ![](images/img_59.png)

<br>

## 編輯腳本

_完成以上步驟後，繼續編輯腳本，特別注意，此時還不要點擊版本控制 。_

<br>

1. 首先確認已完成 `secrets.toml` 文件的編輯。

    ![](images/img_97.png)

<br>

2. 查看 `graph.py`：這將用於生成 `Neo4jGraph` 對象，保持不變。

    ```python
    import streamlit as st
    from langchain_community.graphs import Neo4jGraph

    graph = Neo4jGraph(
        url=st.secrets["NEO4J_URI"],
        username=st.secrets["NEO4J_USERNAME"],
        password=st.secrets["NEO4J_PASSWORD"],
    )

    ```

<br>

3. `agent.py`：這是一個相對重要的腳本；其中 `generate_response()` 函數用於取得用戶文本後生成回應，基於避免程序崩潰的目的，加入了例外處理與條件判斷的處理，但並未添加新的功能；另外，在腳本最下方加入了測試的代碼，這可在服務啟動時同時在終端中先進行一次測試，免去手動輸入對話的麻煩。

    ```python
    from langchain.tools import Tool
    from langchain.agents import AgentExecutor, create_react_agent
    from langchain import hub
    from langchain.chains.conversation.memory import ConversationBufferWindowMemory
    from solutions.llm import llm
    # 在 agent.py 中註冊 Retrieval Chain 作為工具，先導入 kg_qa
    from solutions.tools.vector import kg_qa
    from solutions.tools.finetuned import cypher_qa

    # 在工具陣列中添加 kg_qa
    tools = [
        # 處理一般聊天對話，涵蓋所有其他工具未涵蓋的問題和請求。
        Tool.from_function(
            name="General Chat",
            description="處理一般聊天對話，涵蓋所有其他工具未涵蓋的問題和請求。",
            func=llm.invoke,
            # 不要直接輸出
            return_direct=False,
        ),
        # 用於基於向量搜索的電影情節信息檢索。
        # 如果問題涉及查找與特定電影情節相似的電影，並且需要使用向量搜索技術，會使用此工具。
        Tool.from_function(
            name="Vector Search Index",
            description="用於基於向量搜索的電影情節信息檢索。",
            func=kg_qa,
            # 不要直接輸出
            return_direct=False,
        ),
        # 用於使用 Cypher 查詢語句來回答有關電影的具體問題。
        # 如果問題需要從 Neo4j 數據庫中檢索電影信息，並涉及生成和執行 Cypher 查詢。
        # 注意這裡會調用 cypher_qa
        Tool.from_function(
            # 這名稱會在終端機中顯示為 `Action：Cypher QA`
            name="Cypher QA",
            description="用於使用 Cypher 查詢語句來回答有關電影的具體問題。",
            # 調用 finetuned.py 中自訂的函數 cypher_qa
            func=cypher_qa,
            # 不可以直接回應，否則會出現解析錯誤
            return_direct=False,
        ),
    ]

    # 調用 langchain 函數 ConversationBufferWindowMemory
    memory = ConversationBufferWindowMemory(
        memory_key="chat_history",
        k=5,
        return_messages=True,
    )

    # 調用 langchain 函數 hub.pull() 生成
    agent_prompt = hub.pull("hwchase17/react-chat")
    # 調用 langchain 函數 create_react_agent
    # 傳入 `llm`、`tools`、`Agent 的回應`
    agent = create_react_agent(llm, tools, agent_prompt)
    # 透過 AgentExecutor 類建立代理執行物件
    agent_executor = AgentExecutor(
        agent=agent,
        tools=tools,
        memory=memory,
        verbose=True
    )


    # 修正的腳本
    def generate_response(prompt):
        print(f'=> generate_response 函數輸出 prompt -> {prompt}')
        try:
            print('=> generate_response 函數進入 try')
            # 回應
            response = agent_executor.invoke({"input": prompt})
            print(f'=> response -> {response}')
            # 獲取回應中的 'output' 字段，如果不存在則為 None
            output = response.get('output', None)
            if output is None:
                return "=> 回應 `response` 中沒有結果 `output`。"

            if isinstance(output, dict):
                print('=> agent.py -> 備註：回應是一個 dict=')
                # 將 dict 的項轉換為字符串並連接
                response_output = ', '.join([f"{key}: {value}" for key, value in output.items()])
            elif isinstance(output, str):
                response_output = output
            else:
                raise ValueError(f"=> 非預期的結果型態 `output type` -> {type(output)}")

            # 確保 response_output 是字符串或列表
            if not isinstance(response_output, str):
                raise ValueError(f"=> 無效的回應結果型態 `response output type` -> {type(response_output)}")

            return response_output
        except Exception as e:
            print('=> generate_response 無法解析 -> 回應發生錯誤=')
            return f"=> 錯誤的 response -> {str(e)}"
        finally:
            pass

    # 保留官方原始代碼作為參考
    # def generate_response(prompt):
    #     response = agent_executor.invoke({"input": prompt})
    #     return response["output"]


    # 加入測試代碼
    print('== 進行測試 ==')
    # prompt = "資料庫中的第一個節點訊息是什麼？"
    prompt = "中華職棒當前有哪些球隊？"
    # 調用 generate_response
    response = generate_response(prompt)
    print(response)

    ```

<br>

4. `vector.py`：這個腳本主要用於生成 `agent.py` 在查詢資料庫時所需的函數 `kg_qa()`，這個函數將傳給 `Tool.from_function()` 作為參數。

    ```python
    import streamlit as st
    from langchain_community.vectorstores.neo4j_vector import Neo4jVector
    # from langchain.chains.qa_with_sources import load_qa_with_sources_chain
    from langchain.chains import RetrievalQA
    from solutions.llm import llm, embeddings

    # 使用 Neo4jVector.from_existing_index 方法創建一個 Neo4jVector
    neo4jvector = Neo4jVector.from_existing_index(
        # 用於嵌入用戶輸入的嵌入對象
        embeddings,
        # Neo4j 實例的 URI、帳號密碼
        url=st.secrets["NEO4J_URI"],
        username=st.secrets["NEO4J_USERNAME"],
        password=st.secrets["NEO4J_PASSWORD"],
        # 索引名稱
        index_name="moviePlots",
        # 用於填充索引的節點標籤
        node_label="Movie",
        # 保存原始純文本值的屬性名稱
        text_node_property="plot",
        # 保存原始文本嵌入的屬性名稱
        embedding_node_property="plotEmbedding",
        #
        retrieval_query="""
            RETURN
                node.plot AS text,
                score,
                {
                    title: node.title,
                    directors: [ (person)-[:DIRECTED]->(node) | person.name ],
                    actors: [ (person)-[r:ACTED_IN]->(node) | [person.name, r.role] ],
                    tmdbId: node.tmdbId,
                    source: 'https://www.themoviedb.org/movie/'+ node.tmdbId
                } AS metadata
        """,
    )
    # 創建 Neo4jVector 的 Retriever
    retriever = neo4jvector.as_retriever()
    # 創建新的 RetrievalQA Chain
    kg_qa = RetrievalQA.from_chain_type(
        # 處理鏈的 LLM
        llm,
        # 直接將文檔插入提示並將提示傳遞給 LLM
        chain_type="stuff",
        # 使用之前創建的 Neo4jVectorRetriever
        retriever=retriever,
    )

    ```

<br>

5. `finetuned.py`：這個腳本主要用於生成 `agent.py` 在查詢資料庫時所需的函數 `cypher_qa()`，這個函數將傳給 `Tool.from_function()` 作為參數，其中模板 `CYPHER_GENERATION_TEMPLATE` 用中文或英文書寫皆可，另外暫時不設定模式 `Schema`，之後優化再做補充。

    ```python
    from langchain.chains import GraphCypherQAChain
    from langchain.prompts.prompt import PromptTemplate
    from solutions.llm import llm
    from solutions.graph import graph

    # 添加定義 `模式 Schema`
    # SCHEMA = """
    # (Movie)-[:DIRECTED_BY]->(Director)
    # """

    # 更新模板以包含模式 Schema
    CYPHER_GENERATION_TEMPLATE = """
    你是一名專業的 Neo4j 開發者，將用戶的問題轉換為 Cypher 語句，以回答有關電影的問題並提供推薦。
    根據模式轉換用戶的問題。

    只使用模式中提供的關係類型和屬性。
    不使用任何未提供的關係類型或屬性。

    Fine Tuning:

    對於以 "The" 開頭的電影標題，將 "The" 移到末尾。例如 "The 39 Steps" 變為 "39 Steps, The" 或 "the matrix" 變為 "Matrix, The"。


    Schema:
    {schema}

    Question:
    {question}

    Cypher Query:
    """

    # 使用模板創建一個 PromptTemplate 對象
    cypher_prompt = PromptTemplate.from_template(CYPHER_GENERATION_TEMPLATE)

    # 創建一個 GraphCypherQAChain 對象，用於執行基於圖數據庫的問答
    # 這個函數會在 `agent.py` 中的 `Tool.from_function` 被調用
    cypher_qa = GraphCypherQAChain.from_llm(
        # 使用的語言模型
        llm,
        # 使用的圖數據庫
        # 官方說明中並未提及這個參數，但因為 `langchain_community.chains.graph_qa.cypher.py`
        # 需要傳遞這個參數
        graph=graph,
        # 啟用詳細日誌，設置為 `True` 的時候會顯示詳細的 Embedding
        verbose=False,
        # 使用的 Cypher 查詢模板
        cypher_prompt=cypher_prompt
    )

    ```

<br>

## 彙整

1. 首先修改主腳本 `bot.py`：導入 `generate_response()` 函數，並用於修改原本的 `handle_submit()` 函數。

    ```python
    import streamlit as st
    # 從自訂模組中導入函數
    from utils import write_message
    # 導入生成回覆的函數
    from solutions.agent import generate_response

    # 設定瀏覽器頁籤及圖標
    st.set_page_config("柱子", page_icon=":movie_camera:")

    # 假如訊息狀態字典 `session_state` 中沒有鍵 `messages`
    if "messages" not in st.session_state:
        # 表示這是初次啟動，所以在鍵 `messages` 儲存第一筆資料
        # 稍後會在其他程序中來遍歷這個字典，用以顯示對話
        st.session_state.messages = [{
            "role": "assistant",
            "content": "哈囉，這是初次啟動，請問需要什麼服務？"
        },]


    # 自訂函數：處理提交，傳入一個參數 `message`，最後會顯示在 `助手` 端
    def handle_submit(message):
        # 提交時，會先顯示這個字串
        with st.spinner('讓我思考一下...'):
            # 調用自訂函數 `generate_response`
            # 同時傳入 `handle_submit` 函數所取得的傳入字串來生成回應
            response = generate_response(message)
            # 調用自訂函數 `write_message` 將 `生成的回應` 傳入
            # 並以 `助手` 身份來寫入這個生成的回應
            write_message('assistant', response)


    # 遍歷訊息狀態中的鍵 `messages` 的值
    for message in st.session_state.messages:
        # 調用寫入訊息的函數
        # 因為參數 `save` 是 `False`，所以不會儲存，直接執行 `顯示`
        write_message(
            message['role'],
            message['content'],
            save=False
        )

    # 假如用戶輸入了訊息
    if prompt := st.chat_input("怎麼了？有話就說吧～"):
        # 調用寫入函數，這時候會執行儲存然後顯示在 `user` 端
        write_message('user', prompt)
        # 提交並顯示在助手端
        handle_submit(prompt)

    ```

<br>

## 刪除不需要的腳本

_有許多腳本並未使用到，若擔心可先進行全文註解。_

<br>

1. cypher.py
2. fewshot.py
3. general.py
4. prompts.py
5. scoped.py

<br>

## 其他無用的文件或腳本

_包含範例、說明、雲端設置及編譯檔案。_

<br>

1. 資料夾 `example`。
2. .gitpod.yml：這是用於配置雲端開發環境的設置文件，在這裡並未用到。
3. README.adoc。

4. 刪除以上文件。

    ```bash
    rm -rf example .gitpod.yml README.adoc
    ```

5. 初次運行也可以刪除資料夾中所有的 `__pycache__`，這是用於儲存已編譯的字碼文件，作用是加速啟動，有時候舊的文件在專案進行修改後會影響運行，可進行清理。

    ```bash
    find . -name "__pycache__" -exec rm -rf {} +
    ```

<br>

## 刪除原本的原始檔控制

1. 這是網路下載的倉庫，內含原倉庫原始檔控制的設定文件 `.git`。

   ![](images/img_06.png)

<br>

2. 刪除原有的 Git 設定，過一下左側插件圖標上的藍點自然會消失，或是關閉開啟中的專案後消失。

    ```bash
    rm -rf .git
    ```

<br>

## 測試與除錯

_暫時無法排除_

<br>

_後續要開始進行容器打包，所以在這先進行運行測試，尤其這個實作開始是成功的，後來運行不知原因又
發生錯誤，這裡做個排除紀錄 。_

<br>

1. 發生 `向量索引名稱不存在` 的錯誤。

```vbnet
ValueError: The specified vector index name does not exist. Make sure to check if you spelled it correctly
```

<br>

2. 使用以下腳本檢查向量索引。

   ```python
   from neo4j import GraphDatabase

   # 設定 Neo4j 資料庫的 URI 和認證資訊
   URI = "neo4j+s://bfc46ed1.databases.neo4j.io"
   AUTH = ("neo4j", "8Yc-sCEfoQN5XjrKlV4VqqMilhv6HM4jLrwzLf2P-Ic")

   # 建立 Neo4j 連接
   driver = GraphDatabase.driver(URI, auth=AUTH)

   def create_vector_index():
       with driver.session(database="neo4j") as session:
           result = session.run("SHOW INDEXES")
           indexes = result.data()
           index_names = [index['name'] for index in indexes]
           if 'moviePlots' not in index_names:
               session.run(
                   """
                   CREATE INDEX moviePlots FOR (m:Movie) ON (m.plotEmbedding)
                   """
               )
               print("向量索引 moviePlots 已創建")
           else:
               print("向量索引 moviePlots 已存在")

   def check_indexes():
       with driver.session(database="neo4j") as session:
           result = session.run("SHOW INDEXES")
           indexes = result.data()
           for index in indexes:
               print(index)
           if any(index['name'] == 'moviePlots' for index in indexes):
               print("向量索引 moviePlots 確實存在")
           else:
               print("向量索引 moviePlots 不存在")

   if __name__ == "__main__":
       create_vector_index()
       check_indexes()
       driver.close()
   ```

<br>

3. 查詢結果。

   ![](images/img_85.png)

<br>

4. 嘗試透過腳本運行 Cypher 語法 `DROP INDEX moviePlots` 刪除索引。

   ```python
   from neo4j import GraphDatabase

   # 設定 Neo4j 資料庫的 URI 和認證資訊
   URI = "neo4j+s://bfc46ed1.databases.neo4j.io"
   AUTH = ("neo4j", "8Yc-sCEfoQN5XjrKlV4VqqMilhv6HM4jLrwzLf2P-Ic")

   # 建立 Neo4j 連接
   driver = GraphDatabase.driver(URI, auth=AUTH)

   def drop_vector_index():
       with driver.session(database="neo4j") as session:
           session.run(
               """
               DROP INDEX moviePlots
               """
           )
           print("向量索引 moviePlots 已刪除")

   def check_indexes():
       with driver.session(database="neo4j") as session:
           result = session.run("SHOW INDEXES")
           indexes = result.data()
           for index in indexes:
               print(index)
               if index["name"] == "moviePlots":
                   print("向量索引 moviePlots 存在")
                   return True
           print("向量索引 moviePlots 不存在")
           return False

   if __name__ == "__main__":
       if check_indexes():
           drop_vector_index()
       else:
           print("向量索引 moviePlots 不存在，無需刪除")
       driver.close()
   ```

<br>

## 打包為容器

_在 VSCode 中操作_

1. 開啟 `命令選擇區`。

   ![](images/img_48.png)

<br>

2. 建立容器。

   ![](images/img_07.png)

<br>

3. 將設定新增到工作區。

   ![](images/img_08.png)

<br>

4. 使用 Python3。

   ![](images/img_09.png)

<br>

5. 由於前面提及的版本限制，這裡選擇 `3.10 bulleye`。

   ![](images/img_10.png)

<br>

6. 不用選取任何功能。

   ![](images/img_11.png)

<br>

7. 完成時在容器中重新開啟。

   ![](images/img_12.png)

<br>

8. 會添加設定資料夾與檔案，但內容僅有命名與原來映像，可手動刪除無用的註解。

   ![](images/img_13.png)

<br>

9. 編輯 `devcontainer.json`，除了將版本號改為 `python:3.10-bullseye`，並添加指令使榮器在建立後考會安裝指定的套件，包含 `requirements.txt`、`streamlit`、`python-dotenv`，其中 `streamlit` 已寫入 `requirements.txt`，但 `python-dotenv` 在部署在雲端時無需安裝，所以要另外以指令進行安裝。

   ```json
   {
       // 命名
       "name": "Python 3",
       // 映像
       "image": "mcr.microsoft.com/devcontainers/python:3.10-bullseye",
       // 容器啟動後執行指令進行安裝 `requirements.txt`、`streamlit`、`python-dotenv`
       "updateContentCommand": "[ -f requirements.txt ] && pip3 install --user -r requirements.txt; pip3 install --user streamlit python-dotenv; echo '✅ Packages installed and Requirements met'",
       // 運行主腳本：可加入參數
       // --server.enableCORS false：允許應用接受來自不同埠或域的請求
       // --server.enableXsrfProtection false：禁用保護，在開發階段使用以避免遇到與 CSRF 保護相關的問題
       "postAttachCommand": "streamlit run bot.py"
   }

   ```

<br>

10. 將 `streamlit` 寫入的 `requirements.txt`。

    ```txt
    langchain
    openai
    langchain_openai
    langchainhub
    neo4j-driver
    streamlit
    ```

<br>

11. 延續上一點，同時將 `devcontainer.json` 文件也修改一下，將 `streamlit` 的安裝指令拿掉。

    ```json
    {
        // 命名
        "name": "Python 3",
        // 映像
        "image": "mcr.microsoft.com/devcontainers/python:3.10-bullseye",
        // 容器啟動後執行指令進行安裝
        "updateContentCommand": "[ -f requirements.txt ] && pip3 install --user -r requirements.txt; pip3 install --user python-dotenv; echo '✅ Packages installed and Requirements met'",
        // 運行主腳本：可使用參數
        // --server.enableCORS false：允許應用接受來自不同埠或域的請求
        // --server.enableXsrfProtection false：禁用保護，在開發階段使用以避免遇到與 CSRF 保護相關的問題
        "postAttachCommand": "streamlit run bot.py"
    }

    ```

<br>

12. 修改過設定文件後要重建容器。

    ![](images/img_49.png)

<br>

13. VSCode 左下方的連線顯示連入容器就表示完成。

    ![](images/img_14.png)

<br>

14. 這裡直接按下 `ENTER` 即可。

    ![](images/img_50.png)

<br>

15. 此時可在本地容器運行並進行問答。

    ![](images/img_51.png)

<br>

## 部署到 GitHub

1. 點擊 `原始檔控制`。

   ![](images/img_15.png)

<br>

2. 發佈到 GitHub。

   ![](images/img_16.png)

<br>

3. 自訂一個名稱，然後點擊公開。

   ![](images/img_17.png)

<br>

4. 在 GitHub 上開啟。

   ![](images/img_18.png)

<br>

5. 點擊 `Code` 並建立 `Codespace`。

   ![](images/img_19.png)

<br>

6. 過程中可以點擊 `View logs` 觀察即時訊息，確保沒有錯誤發生。

   ![](images/img_20.png)

_顯示完成時先不急著動作，因為還有一些安裝程序是在建立好之後進行的。_

<br>

7. 看到 `Streamlit` 服務啟動時，可以點擊 `以瀏覽器開啟`，或查看所有的轉接埠。

   ![](images/img_21.png)

<br>

8. 接著就會看到發生錯誤，因為那些敏感資訊都已經被排除了。

   ![](images/img_22.png)

<br>

## 加入敏感資訊

_排除前一個步驟的錯誤訊息_

<br>

1. 在 Codespace 專案資料夾的根目錄中手動建立 `.env` 文件，並將本地的內容複製貼上，用以測試腳本的運行，因為 `.gitignore` 文件是有同步的，所以若更新倉庫不會有安全外洩問題。

   ![](images/img_23.png)

<br>

2. 刷新網頁後，Bot 就可以順利運行。

   ![](images/img_24.png)

<br>

3. 測試一下重建容器。

   ![](images/img_25.png)

<br>

4. 完成後會自動啟動服務，開啟瀏覽器便可進行對話。

   ![](images/img_26.png)

<br>

5. 正常運行。

   ![](images/img_27.png)

<br>

## 部署到 Streamlit 服務器上

_回到本機操作，在 Codespace 也是可以。_

<br>

1. 在專案根目錄中建立一個 `.streamlit` 資料夾，並添加一個 `secrets.toml` 文件。

   ![](images/img_28.png)

<br>

2. 將 `.env` 文件中的內容複製到 `secrets.toml` 文件中，因為在 `.toml` 格式中，等號右側的是 `字串值` ，所以必須加上引號，此時基於 `一致性原則` 可在等號兩側都加上一個空白字元。

   ![](images/img_41.png)

<br>

3. 同樣要把 `secrets.toml` 文件加入 `.gitignore` 中，這部分預設已經寫入。

   ```bash
   # 敏感資訊
   .streamlit/secrets.toml
   .env
   ```

<br>

4. 進入 Streamlit [官網](https://streamlit.io/) 並點擊 `Sign in`，可使用 Google 或 GitHub 帳號登入。

   ![](images/img_29.png)

<br>

5. 假如選擇 Google，接下來還是會詢問是否連結 GitHub 帳號。

   ![](images/img_30.png)

<br>

6. 填寫完畢點擊 `Continue` 完成設定。

   ![](images/img_31.png)

<br>

## 建立專案

1. New app。

   ![](images/img_32.png)

<br>

2. 部署：選取倉庫，最重要的是要修改主腳本的名稱，在這個專案中為 `bot.py`，然後可自訂一個公網名稱，尾綴固定是 `streamlit.app`。

   ![](images/img_33.png)

<br>

3. 接著可點擊 `Advanced settings...`

   ![](images/img_52.png)

<br>

4. 假如未進行設定就進入下一步，會因為尚未設定敏感資訊而出錯的。

   ![](images/img_34.png)

<br>

5. 那就必須回到主控台，在專案右側點擊 `...` 顯示更多來展開，並點擊設定 `Settings`。

   ![](images/img_35.png)

<br>

6. 然後切換到 `Secrets` 進行密鑰等環境參數設定，但特別注意的是，透過這樣的設定步驟將無法選擇 `Python version`，在某些情境下可能會出錯。

   ![](images/img_36.png)

<br>

7. 回到前面 `Advanced settings...` 的步驟，點擊後進入，首先選擇跟容器相同版本的 `3.10`。

   ![](images/img_53.png)

<br>

8. 在 `Secrets` 的部分，因為 `secrets.toml` 文件是排除同步的，所以要將 `secrets.toml` 的內容複製貼在 Streamlit 服務器上。

   ![](images/img_37.png)

<br>

9. 至此，應該要去修改 `graph.py`、`llm.py`、`vector.py` 三個腳本中原本如下圖使用 `os.getenv()` 的部分，因應 `Secrets` 的環境設置而改為 `st.secrets["<鍵>"]`，但這樣的修改模式將使得腳本在不同環境下運作時，又得再次手動修改，相當很麻煩。

   ![](images/img_39.png)

<br>

10. 延續上一點，為了避免這樣的繁瑣，可在專案中添加一個模組 `secret.py` 來判斷所處在的運作環境為何，這裡示範將這個腳本置於 `tools` 資料夾中，函數名稱為 `get_secret()`。

    ```python
    # secret.py
    # 原本沒有導入 dotenv，這裡要添加
    import os
    from dotenv import load_dotenv
    #
    load_dotenv()

    # 新增判斷函數
    def get_secret(key):
        try:
            # 嘗試從 Streamlit secrets 獲取敏感資訊
            return st.secrets[key]
        except AttributeError:
            # 如果 st.secrets 沒有該鍵或 st.secrets 未被設定，則從環境變量中獲取
            return os.getenv(key)
    ```

<br>

11. 分別在  `graph.py`、`llm.py`、`vector.py` 導入函數，其中  `graph.py` 及 `vector.py` 改寫如下。

    _graph.py_

    ```python
    # graph.py
    from langchain_community.graphs import Neo4jGraph
    # 導入自訂函數
    from solutions.tools.secret import get_secret

    # 讀取環境變數
    NEO4J_URI = get_secret("NEO4J_URI")
    NEO4J_USERNAME = get_secret("NEO4J_USERNAME")
    NEO4J_PASSWORD = get_secret("NEO4J_PASSWORD")

    # Neo4j Graph
    graph = Neo4jGraph(
        url=NEO4J_URI,
        username=NEO4J_USERNAME,
        password=NEO4J_PASSWORD,
    )

    ```

    _vector.py_

    ```python
    # vector.py
    from langchain_community.vectorstores.neo4j_vector import Neo4jVector
    from langchain.chains import RetrievalQA
    from solutions.llm import llm, embeddings
    # 導入自訂函數
    from solutions.tools.secret import get_secret

    # 讀取環境變數
    NEO4J_URI = get_secret("NEO4J_URI")
    NEO4J_USERNAME = get_secret("NEO4J_USERNAME")
    NEO4J_PASSWORD = get_secret("NEO4J_PASSWORD")

    neo4jvector = Neo4jVector.from_existing_index(
        embeddings,                 # <1>
        url=NEO4J_URI,              # <2>
        username=NEO4J_USERNAME,    # <3>
        password=NEO4J_PASSWORD,    # <4>
        index_name="moviePlots",    # <5>
        node_label="Movie",         # <6>
        text_node_property="plot",  # <7>
        embedding_node_property="plotEmbedding",  # <8>
        retrieval_query="""
        RETURN
            node.plot AS text,
            score,
            {
                title: node.title,
                directors: [ (person)-[:DIRECTED]->(node) | person.name ],
                actors: [ (person)-[r:ACTED_IN]->(node) | [person.name, r.role] ],
                tmdbId: node.tmdbId,
                source: 'https://www.themoviedb.org/movie/'+ node.tmdbId
            } AS metadata
        """,
    )

    retriever = neo4jvector.as_retriever()

    kg_qa = RetrievalQA.from_chain_type(
        llm,  # <1>
        chain_type="stuff",  # <2>
        retriever=retriever,  # <3>
    )

    ```

<br>

12. 另外 `llm.py` 需要的是 OpenAPI 的 API Key，所以改寫內容與另外兩個腳本不同。

    ```python
    # llm.py
    from langchain_openai import ChatOpenAI
    from langchain_openai import OpenAIEmbeddings
    # 導入自訂函數
    from solutions.tools.secret import get_secret

    # 改寫
    OPENAI_API_KEY = get_secret("OPENAI_API_KEY")
    OPENAI_MODEL = get_secret("OPENAI_MODEL")

    # 建立 ChatOpenAI 實體
    llm = ChatOpenAI(
        openai_api_key=OPENAI_API_KEY,
        model=OPENAI_MODEL,
    )

    # OpenAIEmbeddings 是用來生成和處理嵌入向量（embeddings）
    # 這些嵌入向量是從使用 OpenAI 模型（如 GPT-4）生成的文本中獲取的
    embeddings = OpenAIEmbeddings(openai_api_key=OPENAI_API_KEY)

    ```

<br>

13. 無論以上程序是在本機修改或在 Codespace 進行編輯，都記得要記得同步。

    ![](images/img_54.png)

<br>

14. 進入 Streamlit 主控台，因為專案的設定改變了，所以要進行 `Reboot`，假如只是內容改變可以不用重啟。

    ![](images/img_38.png)

<br>

15. 完成後會出現關於套件 `dotenv` 的錯誤，因為服務器上無法安裝這個套件。

    ![](images/img_40.png)

<br>

16. 修改 `secret.py` 中的 `get_secret()`，將 `dotenv` 的使用移入所在環境判斷的區塊內，只有確認在本機或容器中運行時才導入使用；特別注意，除了要新增 `import streamlit as st`，還要將 `from dotenv import load_dotenv` 註解或刪除。

    ```python
    # secret.py
    import streamlit as st
    import os
    # from dotenv import load_dotenv

    # 判斷環境取得密鑰
    # def get_secret(key):
    #     try:
    #         # 嘗試從 Streamlit secrets 獲取敏感資訊
    #         return st.secrets[key]
    #     except AttributeError:
    #         # 如果 st.secrets 沒有該鍵或 st.secrets 未被設定，則從環境變量中獲取
    #         return os.getenv(key)

    # 改寫
    def get_secret(key):
        # 檢查是否在 Streamlit 雲端環境中運行，Streamlit 雲端環境會設置特定的環境變量
        if 'STREAMLIT_SHARING_MODE' in os.environ:
            # 在 Streamlit 雲端，使用 st.secrets 讀取配置
            try:
                return st.secrets[key]
            except KeyError:
                print(f"Key {key} not found in Streamlit secrets.")
        else:
            # 在本機環境，嘗試從 .env 文件讀取配置
            from dotenv import load_dotenv
            load_dotenv()  # 讀取 .env 文件中的環境變量
            secret_value = os.getenv(key)
            if secret_value is not None:
                return secret_value
            else:
                print(f"Key {key} not found in environment variables.")
    ```

<br>

17. 然後進入 Streamlit 服務器的 `Secrets` 中加入一個新的變數 `STREAMLIT_SHARING_MODE`，這是設計用來判斷當前環境是否為 Streamlit 服務器的一個機制。

    ```bash
    STREAMLIT_SHARING_MODE = 1
    ```

    ![](images/img_42.png)

<br>

18. 切記本機或 Codespace 要進行同步，另外 Streamlit 服務器更新設定都要 `Reboot`；至此無論在 `本機虛擬環境中`、`本機的容器中`、 `Codespace 容器中`，或是部署在 `Streamlit 服務器上` 的應用皆可正常運行了。

    ![](images/img_43.png)

<br>

## 補上四個修改的腳本

1. **secret.py**

   ```python
   # secret.py
   import streamlit as st
   import os


   # 自訂函數
   def get_secret(key):
       # 檢查是否在 Streamlit 雲端環境中運行，Streamlit 雲端環境會設置特定的環境變量
       if "STREAMLIT_SHARING_MODE" in os.environ:
           # 在 Streamlit 雲端，使用 st.secrets 讀取配置
           try:
               return st.secrets[key]
           except KeyError:
               print(f"Key {key} not found in Streamlit secrets.")
       else:
           # 在本機環境，嘗試從 .env 文件讀取配置
           from dotenv import load_dotenv

           load_dotenv()  # 讀取 .env 文件中的環境變量
           secret_value = os.getenv(key)
           if secret_value is not None:
               return secret_value
           else:
               print(f"Key {key} not found in environment variables.")

   ```

<br>

2. **graph.py**

   ```python
   # graph.py
   # 導入自訂函數
   from solutions.tools.secret import get_secret
   from langchain_community.graphs import Neo4jGraph

   # 取得環境變數
   NEO4J_URI = get_secret("NEO4J_URI")
   NEO4J_USERNAME = get_secret("NEO4J_USERNAME")
   NEO4J_PASSWORD = get_secret("NEO4J_PASSWORD")

   # Neo4j Graph
   graph = Neo4jGraph(
       url=NEO4J_URI,
       username=NEO4J_USERNAME,
       password=NEO4J_PASSWORD,
   )

   ```

<br>

3. **llm.py**

   ```python
   # llm.py
   # 導入自訂函數
   from solutions.tools.secret import get_secret
   from langchain_openai import ChatOpenAI
   from langchain_openai import OpenAIEmbeddings

   # 取的環境變數
   OPENAI_API_KEY = get_secret("OPENAI_API_KEY")
   OPENAI_MODEL = get_secret("OPENAI_MODEL")

   # 建立 ChatOpenAI 實體
   llm = ChatOpenAI(
       openai_api_key=OPENAI_API_KEY,
       model=OPENAI_MODEL,
   )

   # OpenAIEmbeddings 是用來生成和處理嵌入向量（embeddings）
   # 這些嵌入向量是從使用 OpenAI 模型（如 GPT-4）生成的文本中獲取的
   embeddings = OpenAIEmbeddings(openai_api_key=OPENAI_API_KEY)

   ```

<br>

4. **vector.py**

   ```python
   # vector.py
   from langchain_community.vectorstores.neo4j_vector import Neo4jVector
   from langchain.chains import RetrievalQA
   from solutions.llm import llm, embeddings
   # 導入自訂函數
   from solutions.tools.secret import get_secret

   # 讀取環境變數
   NEO4J_URI = get_secret("NEO4J_URI")
   NEO4J_USERNAME = get_secret("NEO4J_USERNAME")
   NEO4J_PASSWORD = get_secret("NEO4J_PASSWORD")

   neo4jvector = Neo4jVector.from_existing_index(
       embeddings,                 # <1>
       url=NEO4J_URI,              # <2>
       username=NEO4J_USERNAME,    # <3>
       password=NEO4J_PASSWORD,    # <4>
       index_name="moviePlots",    # <5>
       node_label="Movie",         # <6>
       text_node_property="plot",  # <7>
       embedding_node_property="plotEmbedding",  # <8>
       retrieval_query="""
       RETURN
           node.plot AS text,
           score,
           {
               title: node.title,
               directors: [ (person)-[:DIRECTED]->(node) | person.name ],
               actors: [ (person)-[r:ACTED_IN]->(node) | [person.name, r.role] ],
               tmdbId: node.tmdbId,
               source: 'https://www.themoviedb.org/movie/'+ node.tmdbId
           } AS metadata
       """,
   )

   retriever = neo4jvector.as_retriever()

   kg_qa = RetrievalQA.from_chain_type(
       llm,  # <1>
       chain_type="stuff",  # <2>
       retriever=retriever,  # <3>
   )

   ```

<br>

## 關於 OpenAPI

1. 使用付費服務要特別關注 [使用量](https://platform.openai.com/usage)。

   ![](images/img_44.png)

<br>

2. 會有詳細的用量與帳單資訊。

   ![](images/img_45.png)

<br>

---

_END_
