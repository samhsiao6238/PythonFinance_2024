# 向量搜尋 + LangChain

1. 這個範例可參考前面的筆記 `08` 可能還更清楚一些，想說既然做了就把它寫完。

2. 結合 MongoDB Atlas 與 LangChain 進行向量搜索，[官網文章](https://www.mongodb.com/developer/products/atlas/leveraging-mongodb-atlas-vector-search-langchain/)。

<br>

## 簡介

1. 向量搜索引擎，或稱 `向量數據庫`、`語義搜索`、`餘弦搜索`，能找到與指定向量化查詢最接近的條目。

<br>

2. 傳統的搜索方法依賴於 `關鍵字匹配`、`詞頻` 等，而向量搜索引擎則通過在 `嵌入空間` 中的 `距離` 來衡量相似性，這種搜索方法使得查找相關數據變得更為有效。

<br>

3. `向量嵌入` 是數據及其上下文的數值表示，通常以高維度的密集向量形式儲存，有多種模型如 `OpenAI` 和 `Hugging Face` 提供的模型可以生成這些嵌入，這些模型經過大量樣本訓練，能提供更為準確和相關的結果。

<br>

4. 在某些情況下，數據本身的數值特徵也可作為嵌入，`MongoDB Atlas` 提供了一個高效的搜索機制來管理這些嵌入。

<br>

## MongoDB Atlas 向量搜索

1. `MongoDB Atlas` 是一個完全托管的雲端數據庫，支持 `AWS`、`Azure` 和 `GCP`。

<br>

2. Atlas 引入了原生的向量搜索功能，可以在 MongoDB 文檔數據中進行向量搜索，Atlas 向量搜索利用分層導航小世界（HNSW）算法來執行語義搜索，可以進行類似產品搜索、圖片搜索等。

<br>

## $vectorSearch 運算子

1. Atlas 向量搜索查詢採用 `聚合管道階段（aggregation pipeline stage）` 形式，使用新的 `$vectorSearch` 運算子，該階段在指定欄位上進行向量搜索，該欄位必須用向量類型索引。

<br>

2. `$vectorSearch` 必須是 `管道（pipeline）` 中出現的第一個 `階段（stage）`。

<br>

## LangChain 簡介

1. LangChain 是一個開源框架，旨在幫助開發者透過簡化的 `大型語言模型（LLMs）` 創建應用程序。

<br>

2. LangChain 支持與各種數據源連接，提供更豐富和個性化的體驗。例如，開發者可以使用 LangChain 創建應用程序，通過 LLM 生成查詢的向量表示，並利用 MongoDB Atlas 的向量搜索功能進行搜索，返回相關結果。

<br>

## 環境設置

1. 首先要在 `Atlas UI` 中創建 `向量搜索索引`，這裏將 `嵌入向量欄位` 命名為 `embedding`。

    ![](images/img_81.png)

    ```json
    {
    "fields": [
        {
        "type": "vector",
        "path": "embedding",
        "numDimensions": 1536,
        "similarity": "cosine"
        }
    ]
    }
    ```

<br>

2. 安裝相關套件，包含會使用 OpenAI 生成向量嵌入。

    ```bash
    pip3 install pip --upgrade
    pip3 install langchain pymongo openai pypdf tiktoken
    ```

<br>

3. 設置環境變量，包含 Atlas 超連結和 OpenAI API key。

    ```bash
    export OPENAI_API_KEY="your_openai_api_key"
    export ATLAS_CONNECTION_STRING="your_atlas_connection_string"
    ```

<br>

4. 完整代碼，包含 PDF 文檔的處理、向量化以及索引到 MongoDB Atlas。

    ```python
    import os
    from pymongo import MongoClient
    from langchain.document_loaders import PyPDFLoader
    from langchain.text_splitter import RecursiveCharacterTextSplitter
    from langchain.embeddings import OpenAIEmbeddings
    from langchain.vectorstores import MongoDBAtlasVectorSearch

    # 定義 PDF 文檔的 URL
    pdf_url = "https://query.prod.cms.rt.microsoft.com/cms/api/am/binary/RE4HkJP"

    # 獲取環境變量
    OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
    if not OPENAI_API_KEY:
        raise ValueError("The OPENAI_API_KEY environment variable is not set.")

    ATLAS_CONNECTION_STRING = os.getenv('ATLAS_CONNECTION_STRING')
    if not ATLAS_CONNECTION_STRING:
        raise ValueError("The ATLAS_CONNECTION_STRING environment variable is not set.")

    # 連接到 MongoDB Atlas 集群
    cluster = MongoClient(ATLAS_CONNECTION_STRING)

    # 定義數據庫和集合名稱
    DB_NAME = "langchain"
    COLLECTION_NAME = "vectorSearch"

    # 連接到特定的集合
    MONGODB_COLLECTION = cluster[DB_NAME][COLLECTION_NAME]

    # 初始化 PDF 加載器
    loader = PyPDFLoader(pdf_url)
    data = loader.load()

    # 初始化文本分割器
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=1000, chunk_overlap=150
    )

    # 將文檔分割為可管理的段落
    docs = text_splitter.split_documents(data)

    # 初始化 MongoDB Atlas 向量搜索
    vector_search = MongoDBAtlasVectorSearch.from_documents(
        documents=docs,
        embedding=OpenAIEmbeddings(),
        collection=MONGODB_COLLECTION,
        # 使用預定義的索引名
        index_name="default"
    )

    # 函數：創建 MongoDBAtlasVectorSearch 對象
    def create_vector_search():
        vector_search = MongoDBAtlasVectorSearch.from_connection_string(
            ATLAS_CONNECTION_STRING,
            f"{DB_NAME}.{COLLECTION_NAME}",
            OpenAIEmbeddings(),
            index_name="default"
        )
        return vector_search

    # 函數：執行相似度搜索
    def perform_similarity_search(query, top_k=3):
        vector_search = create_vector_search()
        results = vector_search.similarity_search_with_score(
            query=query,
            k=top_k,
        )
        return results

    # 執行搜索範例
    search_results = perform_similarity_search("MongoDB Atlas auditing")
    for result in search_results:
        print(f"Document: {result[0].page_content}\nSimilarity Score: {result[1]}")
    ```

<br>

___

_END_