_å°šæœªå®Œæˆ_

# å°ˆæ¡ˆèªªæ˜

_ä¾†æºçš„éƒ¨åˆ†å…ˆçœç•¥ï¼Œä¹‹å¾Œå†è£œä¸Šï¼Œé€™è£¡å…ˆèªªæˆ‘çš„è§£æ_ã€‚

<br>

## å°ˆæ¡ˆä»‹ç´¹

1. æ­¤å°ˆæ¡ˆåˆ©ç”¨ç¾ä»£ NLP å·¥å…·å’Œåœ–å½¢è³‡æ–™åº«æŠ€è¡“ä¾†å»ºç«‹é«˜äº’å‹•æ€§çš„æ‡‰ç”¨ç¨‹åºï¼Œå®ƒä¸åƒ…æä¾›äº†è±å¯Œçš„ç”¨æˆ¶äº’å‹•æ–¹å¼ï¼ŒåŒæ™‚ä¹Ÿåˆ©ç”¨äº† `LLM` çš„å¼·å¤§èªè¨€ç†è§£èƒ½åŠ›ä¾†æå‡è¨Šæ¯æª¢ç´¢å’Œæ•¸æ“šè§£é‡‹çš„æ•ˆç‡ã€‚ 

2. é€™å€‹å°ˆæ¡ˆçš„ä¸»è¦è¨­è¨ˆæ¦‚å¿µæ˜¯çµåˆ `Streamlit` å’Œ `Langchain` ä¾†å¯¦ç¾ä¸€å€‹äº’å‹•å¼çš„å°è©±å¼ç•Œé¢ï¼Œé€™å€‹ç•Œé¢å¯ä»¥é€šé `OpenAI` çš„èªè¨€æ¨¡å‹ `LLM` èˆ‡ `Neo4j` åœ–å½¢è³‡æ–™åº«é€²è¡Œäº’å‹•ï¼Œä»¥æä¾›åŸºæ–¼åœ–æ•¸æ“šçš„å•ç­”å’Œæ•¸æ“šè¦–è¦ºåŒ–ã€‚

<br>

## ä½¿ç”¨å¥—ä»¶èªªæ˜

1. Streamlitï¼šåœ¨é€™å€‹å°ˆæ¡ˆä¸­ï¼Œ`Streamlit` ç”¨ä½œæ‡‰ç”¨ç¨‹åºçš„å‰ç«¯å’Œç”¨æˆ¶ç•Œé¢ï¼Œå…è¨±ç”¨æˆ¶é€šéç¶²é èˆ‡ç³»çµ±äº’å‹•ã€‚
   
2. Langchainï¼šç”¨æ–¼å¿«é€Ÿå»ºç«‹å’Œéƒ¨ç½²æ•¸æ“šé©…å‹•çš„ Web æ‡‰ç”¨ç¨‹åºï¼Œé€™æ˜¯ä¸€å€‹ç”¨æ–¼çµåˆèªè¨€æ¨¡å‹èˆ‡å¤–éƒ¨è³‡æ–™ä¾†æºçš„ Python åº«ã€‚åœ¨é€™å€‹å°ˆæ¡ˆä¸­ï¼Œ`Langchain` ç”¨ä¾†æ•´åˆ OpenAI çš„ `GPT-4` æ¨¡å‹èˆ‡ Neo4j åœ–å½¢è³‡æ–™åº«ï¼Œå¯¦ç¾æ™ºèƒ½çš„å•ç­”ç³»çµ±ã€‚
   
3. Neo4jï¼šä¸€å€‹é«˜æ€§èƒ½çš„åœ–å½¢è³‡æ–™åº«ï¼Œæ”¯æŒå„²å­˜è¤‡é›œçš„ç¶²çµ¡çµæ§‹çš„æ•¸æ“šï¼Œé€™å€‹å°ˆæ¡ˆä¸­ä½¿ç”¨ Neo4j ä¾†å„²å­˜å’Œç®¡ç†åœ–å½¢æ•¸æ“šï¼Œä¸¦é€šéæŸ¥è©¢èªè¨€ `Cypher` ä¾†æª¢ç´¢ç›¸é—œè¨Šæ¯ã€‚
   
4. Graphvizï¼šç”¨æ–¼ç”Ÿæˆå’Œå‘ˆç¾åœ–å½¢çµæ§‹çš„å·¥å…·ï¼Œé€™åœ¨å°ˆæ¡ˆä¸­ç”¨æ–¼å°‡åœ–å½¢æ•¸æ“šè¦–è¦ºåŒ–ï¼Œä»¥ä¾¿æ–¼ç”¨æˆ¶ç†è§£æ•¸æ“šä¹‹é–“çš„é—œè¯å’Œçµæ§‹ã€‚

<br>

## ç›¸é—œéŒ¯èª¤æ’é™¤

_é—œæ–¼ç¯„ä¾‹è…³æœ¬é‹è¡Œæ™‚å‡ºç¾çš„éŒ¯èª¤ï¼Œä»¥ä¸‹é€²è¡Œæ’é™¤ç´€éŒ„_

<br>

1. æ›´æ–°å¥—ä»¶

    ```bash
    pip install -U langchain-openai
    ```

<br>

2. æ›´æ–°å°å…¥åº«ã€‚

    ```python
    # from langchain.chat_models import ChatOpenAI
    from langchain_openai import ChatOpenAI
    # from langchain.graphs import Neo4jGraph
    from langchain_community.graphs import Neo4jGraph
    ```

<br>

3. åœ¨å®¹å™¨ä¸­å®‰è£å¥—ä»¶ã€‚

    ```bash
    sudo apt-get update && sudo apt-get install curl telnet -y
    ```

<br>

4. æ¸¬è©¦ã€‚

    ```bash
    telnet demo.neo4jlabs.com 7687
    ```

<br>

## é—œæ–¼ `graphviz` å®‰è£

1. æŒ‡ä»¤ã€‚

    ```bash
    pip install graphviz && brew install graphviz
    ```

<br>

2. ç•¶åœ¨ Python ä¸­ä½¿ç”¨ `graphviz` åº«æ™‚ï¼Œå¯¦éš›ä¸Šéœ€è¦èª¿ç”¨  `graphviz`  çš„ç³»çµ±ç´šäºŒé€²åˆ¶æ–‡ä»¶ä¾†åŸ·è¡Œæ“ä½œã€‚å› æ­¤ï¼Œé™¤äº†åœ¨ Python è™›æ“¬ç’°å¢ƒä¸­å®‰è£ `graphviz` Python åº«ï¼Œä»ç„¶éœ€è¦åœ¨ç³»çµ±å±¤é¢å®‰è£å…¶ç›¸æ‡‰çš„äºŒé€²åˆ¶æ–‡ä»¶å’Œåº«ï¼Œä»¥ç¢ºä¿æ‰€æœ‰åŠŸèƒ½éƒ½å¯ä»¥æ­£å¸¸å·¥ä½œï¼Œç‰¹åˆ¥æ³¨æ„ï¼Œé€™ä¸¦ä¸ä»£è¡¨å¯ä»¥çœå»åœ¨è™›æ“¬ç’°å¢ƒå®‰è£å¥—ä»¶ã€‚

<br>

## æ­¥é©Ÿè¨˜éŒ„

_åŒ…å«äº†å®¹å™¨çš„é‡å»º_

<br>

1. å› ç‚ºä½¿ç”¨å®¹å™¨ï¼Œæ‰€ä»¥ä¸ç”¨å»ºç«‹æˆ–æŒ‡å®šè™›æ“¬ç’°å¢ƒï¼Œå»ºç«‹å°ˆæ¡ˆè³‡æ–™å¤¾ä¸¦å•Ÿå‹• VSCodeã€‚

  ```bash
  cd ~/Desktop && mkdir neo4jBot && cd neo4jBot && code .
  ```

<br>

2. åœ¨ç•¶å‰è·¯å¾‘ä¸­å»ºç«‹å®¹å™¨è³‡æ–™å¤¾ï¼Œä¸¦å»ºç«‹`é–‹ç™¼å®¹å™¨é…ç½®æ–‡ä»¶`ï¼Œæª”åç‚º `devcontainer.json`ï¼Œé€™æ˜¯ç”¨ä¾†é…ç½® VSCode ä¸­çš„é–‹ç™¼å®¹å™¨ç’°å¢ƒæ‰€ç”¨ï¼Œé€²éšç”¨æˆ¶å¯åƒè€ƒä½¿ç”¨ `Dockerfile` é€²è¡Œç’°å¢ƒå»ºç½®ã€‚

  ```bash
  mkdir .devcontainer && touch .devcontainer/devcontainer.json
  ```

<br>

3. é—œæ–¼ä½¿ç”¨ `æ˜ åƒæª”æ¡ˆ`ã€`Dockerfiles` æˆ– `Docker Compose` å®‰è£çš„ç›¸é—œæŠ€è¡“å¯åƒè€ƒ [ Dev Container å®˜æ–¹èªªæ˜](https://containers.dev/guide/dockerfile)ã€‚

<br>

4. ç·¨è¼¯ `devcontainer.json` å…§å®¹å¦‚ä¸‹ã€‚

  ```json
  {
    // æŒ‡å®šé–‹ç™¼ç’°å¢ƒåç¨±ï¼Œé€™æ˜¯å¯ä»¥è‡ªè¨‚çš„
    "name": "Python 3",
    // å®¹å™¨åŸºæ–¼çš„æ˜ åƒï¼Œç•¶å‰è¨­å®šä½¿ç”¨å¾®è»Ÿçš„ `python:1-3.11-bullseye`
    "image": "mcr.microsoft.com/devcontainers/python:1-3.11-bullseye",
    "customizations": {
      // æŒ‡å®šåœ¨ Codespace ä¸­è¦ä½¿ç”¨çš„è¨­å®šï¼Œç‰¹åˆ¥æ³¨æ„é€™è£¡æ˜¯ç›¸å°æ–¼æ ¹ç›®éŒ„çš„è·¯å¾‘
      "codespaces": {
        "openFiles": ["README.md", "app.py"]
      },
      // åœ¨ VScode ä¸­çš„è¨­å®šèˆ‡æ‹“å±•æ’ä»¶
      "vscode": {
        "settings": {},
        "extensions": ["ms-python.python", "ms-python.vscode-pylance"]
      }
    },
    // æª¢æŸ¥ `packages.txt` ä¸¦å®‰è£å…¶ä¸­åˆ—å‡ºçš„ Debian è»Ÿé«”åŒ…
    // æª¢æŸ¥ `requirements.txt` ä¸¦å®‰è£æŒ‡å®šçš„ Python å¥—ä»¶
    // å®‰è£ `streamlit` ä»¥åŠç›¸é—œæ›´æ–°
    "updateContentCommand": "[ -f packages.txt ] && sudo apt update && sudo apt upgrade -y && sudo xargs apt install -y <packages.txt; [ -f requirements.txt ] && pip3 install --user -r requirements.txt; pip3 install --user streamlit; echo 'âœ… Packages installed and Requirements met'",
    // é€™å€‹æŒ‡ä»¤æ˜¯åœ¨é™„åŠ å®¹å™¨å¾Œé‹è¡Œ
    "postAttachCommand": {
      // --server.enableCORS å…·æœ‰è·¨åŸŸè³‡æºå…±äº«(CORS)åŠŸèƒ½
      // é€™å€‹è¨­å®šæ˜¯åœ¨å—æ§ç’°å¢ƒä¸­åŸ·è¡Œæœå‹™ä¸¦å¸Œæœ›é¿å…å¯èƒ½ä½¿é–‹ç™¼äº’å‹•è¤‡é›œåŒ–çš„å®‰å…¨æªæ–½æ™‚ä½¿ç”¨
      "server": "streamlit run app.py --server.enableCORS false --server.enableXsrfProtection false"
    },
    // å®šç¾©å¦‚ä½•è™•ç†å®¹å™¨å…§çš„ç‰¹å®šé€£æ¥åŸ 
    "portsAttributes": {
      "7687": {
        "label": "Neo4j Bolt Port",
        "onAutoForward": "ignore"
      },
      "8501": {
        "label": "Streamlit Application",
        "onAutoForward": "openPreview"
      }
    },
    // åˆ—å‡ºå®¹å™¨å•Ÿå‹•æ™‚æ‡‰è‡ªå‹•è½‰é€çš„é€£æ¥åŸ 
    "forwardPorts": [8501, 7687]
  }
  ```

<br>

5. å»¶çºŒä¸Šä¸€é»ï¼Œç‰¹åˆ¥ç•™æ„éµå€¼ `postAttachCommand` ä¸­çš„æŒ‡ä»¤æ˜¯æœ‰è·¯å¾‘çš„ï¼Œç•¶å‰åœ¨åŒç´šè·¯å¾‘æ‰€ä»¥æ˜¯ `streamlit run app.py`ï¼Œè‹¥å°‡ `app.py` ç½®æ–¼ä¸åŒå±¤ç´šè·¯å¾‘ï¼Œå‰‡éœ€é€²è¡Œä¿®æ”¹ï¼Œä¾‹å¦‚å°‡å…¶è‡³æ–¼å­ç›®éŒ„ `src` ä¸­ï¼Œå‰‡æ˜¯ `streamlit run sec/app.py`

<br>

6. å»ºç«‹å¥—ä»¶çµ±ç±Œæ–‡ä»¶ `requirements.txt`ã€‚

  ```bash
  touch requirements.txt
  ```

<br>

7. åŠ å…¥ä»¥ä¸‹å¥—ä»¶ã€‚

  ```bash
  streamlit==1.26.0
  openai
  langchain
  langchain-openai
  neo4j
  graphviz==0.20.1
  pydantic==2.3.0
  python-dotenv
  ```

<br>

8. å»ºç«‹ .env æ–‡ä»¶ï¼Œä¸¦å¯«å…¥ OpenAI çš„ API Keyã€‚

  ```bash
  touch .env
  ```

  ![](images/img_02.png)

<br>

9. é»æ“Š `åœ¨å®¹å™¨ä¸­é‡æ–°é–‹å•Ÿ`ï¼Œé€™æ™‚ä¾¿æœƒå•Ÿå‹•å®¹å™¨çš„å»ºç«‹ã€‚

  ![](images/img_01.png)

<br>

10. ç‰¹åˆ¥æ³¨æ„ï¼Œ`Neo4jGraph` çš„å¯¦é«”ä¸æ”¯æ´ `with` ä½œç‚ºä¸Šä¸‹æ–‡ç®¡ç†ï¼ˆcontext managerï¼‰ï¼Œæ‰€ä»¥ä¹Ÿæ²’æœ‰ `close` ç­‰é—œé–‰æ–¹æ³•ï¼Œæ‰€ä»¥ä¹Ÿç„¡æ³•ä½¿ç”¨ `try-except` ä¸­çš„ `finally` ä¾†é”åˆ°åŸ·è¡Œå®Œç•¢æ™‚é€€å‡ºçš„æ©Ÿåˆ¶ã€‚

<br>

11. ç•¶å‰çš„ `app.py`ã€‚

  ```python
  """
  é€™æ˜¯ä¸€å€‹å®Œæ•´çš„ Streamlit å’Œ Langchain çš„é›†æˆè…³æœ¬ï¼›
  å¯åˆ©ç”¨ OpenAI çš„èªè¨€æ¨¡å‹å’Œ Neo4j åœ–å½¢è³‡æ–™åº«é€²è¡Œå°è©±ã€‚
  """

  #
  from typing import List, Union
  import streamlit as st

  # ç”¨æ–¼å»ºç«‹å’Œå‘ˆç¾åœ–å½¢çµæ§‹
  import graphviz

  # å¾Langchainå¼•å…¥ç”¨æ–¼OpenAIèŠå¤©æ¨¡å‹çš„å°è£
  # from langchain.chat_models import ChatOpenAI
  from langchain_openai import ChatOpenAI


  # å¼•å…¥Langchainå°Neo4jåœ–å½¢è³‡æ–™åº«çš„å°è£
  # from langchain.graphs import Neo4jGraph
  from langchain_community.graphs import Neo4jGraph


  # å¼•å…¥Langchainæ¶ˆæ¯æ¶æ§‹
  from langchain.schema import HumanMessage, AIMessage

  # å¼•å…¥è‡ªå®šç¾©çš„Cypheréˆå’Œæå•æç¤º
  from cypher_chain import CYPHER_QA_PROMPT, CustomCypherChain

  import os
  # è¼‰å…¥ dotenv
  from dotenv import load_dotenv

  # è¼‰å…¥ç’°å¢ƒè®Šæ•¸
  load_dotenv()

  # è¨­ç½® OpenAI API Key
  openai_api_key = os.getenv("OPENAPI_API_KEY")
  # å°‡APIéµè¨­å®šç‚ºç’°å¢ƒè®Šæ•¸
  os.environ["OPENAI_API_KEY"] = openai_api_key

  # è¨­å®šStreamlité é¢æ¨™é¡Œ
  st.title("VC Chatbot")

  # è¨­å®šNeo4jè³‡æ–™åº«çš„é€£æ¥è¨Šæ¯
  # url = "neo4j+s://demo.neo4jlabs.com"
  url = "neo4j+s://demo.neo4jlabs.com:7687"
  username = "companies"
  password = "companies"
  database = "companies"

  # å»ºç«‹ä¸€å€‹Neo4jåœ–å½¢è³‡æ–™åº«å¯¦ä¾‹
  graph = Neo4jGraph(username=username, password=password, url=url, database=database)

  # å¾èªè¨€æ¨¡å‹å»ºç«‹è‡ªå®šç¾©çš„CypheræŸ¥è©¢éˆ
  graph_search = CustomCypherChain.from_llm(
      # è¨­ç½®OpenAIèŠå¤©æ¨¡å‹
      cypher_llm=ChatOpenAI(temperature=0.0, model_name="gpt-4"),
      # è¨­ç½®ç”¨æ–¼å•ç­”çš„OpenAIæ¨¡å‹
      qa_llm=ChatOpenAI(temperature=0.0),
      # æŒ‡å®šåœ–å½¢è³‡æ–™åº«ï¼Œå‚³å…¥å‰ä¸€å€‹æ­¥é©Ÿå»ºç«‹çš„è³‡æ–™åº«å¯¦ä¾‹
      graph=graph,
      # è¨­ç½®æŸ¥è©¢æç¤ºï¼Œé€™æ˜¯å¾è‡ªè¨‚æ¨¡çµ„ä¸­å°å…¥çš„
      qa_prompt=CYPHER_QA_PROMPT,
  )

  # åˆå§‹åŒ– session stateï¼Œç¢ºä¿æ¯æ¬¡åŸ·è¡Œæ‡‰ç”¨ç¨‹å¼æ™‚ï¼Œç›¸é—œçš„æ•¸æ“šå’Œè®Šæ•¸éƒ½è¢«æ­£ç¢ºè¨­ç½®å’Œè·Ÿè¸ª
  # åœ¨ Streamlit æ‡‰ç”¨ä¸­ï¼Œ`st.session_state`` æ˜¯ç”¨åœ¨è·¨é é¢è«‹æ±‚æ™‚ä¿å­˜ç‹€æ…‹çš„å·¥å…·
  # æª¢æŸ¥æ˜¯å¦åŒ…å«äº†ç‰¹å®šçš„ keyï¼Œå¦‚æœæ²’æœ‰å°±åˆå§‹åŒ–ä¸¦è³¦äºˆä¸€å€‹ç©ºåˆ—è¡¨
  # å¯ç¢ºä¿é€™äº›éµåœ¨å¾ŒçºŒæ“ä½œä¸­å·²ç¶“è¢«å®šç¾©ä¸¦å¯ç”¨æ–¼å„²å­˜æ•¸æ“šã€‚
  if "generated" not in st.session_state:
      st.session_state["generated"] = []

  if "user_input" not in st.session_state:
      st.session_state["user_input"] = []

  if "viz_data" not in st.session_state:
      st.session_state["viz_data"] = []

  if "database" not in st.session_state:
      st.session_state["database"] = []

  if "cypher" not in st.session_state:
      st.session_state["cypher"] = []

  # ç”ŸæˆèŠå¤©æ©Ÿå™¨ä¸‹å›æ‡‰çš„ä¸Šä¸‹æ–‡
  # åƒæ•¸èˆ‡å›å‚³å€¼ï¼š
  # prompt: å­—ä¸²ï¼Œè¡¨ç¤ºç•¶å‰ç”¨æˆ¶çš„è¼¸å…¥ã€‚
  # context_data: å­—ä¸²ï¼Œé è¨­ç‚º "generated"ï¼Œç”¨ä¾†æŒ‡å®šå¾ st.session_state ä¸­è®€å–å“ªå€‹å°è©±æ•¸æ“šï¼Œé€šå¸¸æ˜¯ç”¨ä¾†æŒ‡å®šæ˜¯å¾å“ªé¡å‹çš„æ¶ˆæ¯ä¸­æŠ½å–æ­·å²æ•¸æ“šã€‚
  # è¿”å›ä¸€å€‹åˆ—è¡¨ï¼ŒåŒ…å«æ··åˆé¡å‹çš„ AIMessage å’Œ HumanMessage å°è±¡ï¼Œé€™äº›å°è±¡ä»£è¡¨äº†ç”Ÿæˆå›æ‡‰æ‰€éœ€çš„ä¸Šä¸‹æ–‡ã€‚

  def generate_context(
      prompt: str, context_data: str = "generated"
  ) -> List[Union[AIMessage, HumanMessage]]:
      # å»ºç«‹ç©ºåˆ—è¡¨ç”¨ä¾†å„²å­˜å°è©±çš„ä¸Šä¸‹æ–‡
      context = []
      # å‡å¦‚æœ‰æ­·å²å°è©±
      if st.session_state["generated"]:
          # å…ˆè¨ˆç®—æ­·å²å°è©±çš„æ•¸é‡
          size = len(st.session_state["generated"])
          # åªå–æœ€å¾Œä¸‰æ¢å°è©±é€²è¡Œä¸Šä¸‹æ–‡ç”Ÿæˆ
          for i in range(max(size - 3, 0), size):
              # æŠŠæ¯æ¢å°è©±ä¸­ `ç”¨æˆ¶çš„è¼¸å…¥`èˆ‡`AIçš„å›æ‡‰`æ·»åŠ åˆ° `context` åˆ—è¡¨
              context.append(HumanMessage(content=st.session_state["user_input"][i]))
              context.append(AIMessage(content=st.session_state[context_data][i]))
      # å…ˆå°‡ç•¶å‰ç”¨æˆ¶çš„è¼¸å…¥ `prompt` è½‰æ›ç‚º `HumanMessage` ç‰©ä»¶ï¼Œ
      # å†å°‡ç”¨æˆ¶çš„è¼¸å…¥ï¼Œç„¶å¾Œæ·»åŠ åˆ° `context`
      context.append(HumanMessage(content=str(prompt)))
      # å‚³å‡º
      return context


  # å‹•æ…‹ç”Ÿæˆå¤šå€‹éŸ¿æ‡‰æ¨™ç±¤ï¼ˆTabsï¼‰ï¼Œä¸¦æ ¹æ“šç”¨æˆ¶èˆ‡ AI å°è©±çš„å…§å®¹å’Œçµæœä¾†å±•ç¤ºç›¸æ‡‰çš„æ•¸æ“šå’Œè¦–è¦ºåŒ–è¨Šæ¯
  # åƒæ•¸ iï¼šè¡¨ç¤ºè¦å±•ç¤ºçš„å°è©±å’Œç›¸é—œæ•¸æ“šåœ¨åˆ—è¡¨ä¸­çš„ç´¢å¼•
  def dynamic_response_tabs(i):
      # å»ºç«‹ä¸€å€‹åˆ—è¡¨ tabs_to_addï¼Œé è¨­åŒ…å« `ğŸ’¬Chat` æ¨™ç±¤ï¼Œæ­¤æ¨™ç±¤ç”¨æ–¼å±•ç¤ºç”¨æˆ¶å’Œ AI çš„å°è©±
      tabs_to_add = ["ğŸ’¬Chat"]
      # å®šç¾©ä¸€å€‹å­—å…¸ä¾†å„²å­˜å„é¡æ•¸æ“šçš„å­˜åœ¨æª¢æŸ¥
      data_check = {
          # å±•ç¤ºç”Ÿæˆçš„ Cypher æŸ¥è©¢èªå¥
          "ğŸ”Cypher": st.session_state["cypher"][i],
          # å±•ç¤ºå¾è³‡æ–™åº«æŸ¥è©¢çš„çµæœ
          "ğŸ—ƒï¸Database results": st.session_state["database"][i],
          # å±•ç¤ºæ•¸æ“šçš„è¦–è¦ºåŒ–ï¼Œæ­¤è™•ä½¿ç”¨äº† `çŸ­è·¯è©•ä¼°` ç¢ºä¿å°æ‡‰æ•¸æ“šç´¢å¼•å­˜åœ¨
          "ğŸ•¸ï¸Visualization": st.session_state["viz_data"][i]
          and st.session_state["viz_data"][i][0],
      }

      # éæ­· data_checkï¼Œå°‡æœ‰æ•¸æ“šçš„æ¨™ç±¤åŠ å…¥åˆ°å‰é¢å»ºç«‹çš„åˆ—è¡¨ `tabs_to_add`
      for tab_name, has_data in data_check.items():
          if has_data:
              tabs_to_add.append(tab_name)

      # å»ºç«‹ä¸€å€‹å°è©±æ¡†ä¾†å±•ç¤ºç”¨æˆ¶çš„è¼¸å…¥
      with st.chat_message("user"):
          # å±•ç¤ºæŒ‡å®šç´¢å¼•çš„ç”¨æˆ¶è¼¸å…¥
          st.write(st.session_state["user_input"][i])
      # å»ºç«‹ä¸€å€‹å°è©±æ¡†ä¾†å±•ç¤ºåŠ©ç†çš„å›æ‡‰
      with st.chat_message("assistant"):
          # å»ºç«‹å¤šå€‹æ¨™ç±¤ï¼Œæ ¹æ“šå…ˆå‰æª¢æŸ¥çš„æ•¸æ“šé¡å‹å‹•æ…‹æ·»åŠ 
          selected_tabs = st.tabs(tabs_to_add)
          # éæ­·ä¸¦å±•ç¤ºæ¯å€‹æ¨™ç±¤å°æ‡‰çš„å…§å®¹
          with selected_tabs[0]:
              st.write(st.session_state["generated"][i])
          # å‡å¦‚æ•¸é‡å¤šæ–¼ 1
          if len(selected_tabs) > 1:
              # ç¬¬ä¸€å€‹æ¨™ç±¤å§‹çµ‚å±•ç¤º AI ç”Ÿæˆçš„å›æ‡‰
              with selected_tabs[1]:
                  st.code(st.session_state["cypher"][i], language="cypher")
          # å¦‚æœæœ‰é¡å¤–çš„æ¨™ç±¤ï¼Œå‰‡æ ¹æ“šå…¶é¡å‹å±•ç¤º Cypher èªå¥ã€è³‡æ–™åº«çµæœæˆ–è¦–è¦ºåŒ–å…§å®¹
          if len(selected_tabs) > 2:
              with selected_tabs[2]:
                  st.write(st.session_state["database"][i])
          if len(selected_tabs) > 3:
              with selected_tabs[3]:
                  # è‹¥å­˜åœ¨è¦–è¦ºåŒ–æ•¸æ“šï¼Œå‰‡ä½¿ç”¨ graphviz.Digraph() å»ºç«‹ä¸€å€‹æœ‰å‘åœ–
                  graph_object = graphviz.Digraph()
                  # æ·»åŠ ç¯€é»å’Œé‚Š
                  # æ ¹æ“š st.session_state["viz_data"][i] å„²å­˜çš„è¦–è¦ºåŒ–æ•¸æ“šå»ºç«‹åœ–å½¢
                  for final_entity in st.session_state["viz_data"][i][1]:
                      graph_object.node(
                          final_entity, fillcolor="lightblue", style="filled"
                      )
                  for record in st.session_state["viz_data"][i][0]:
                      graph_object.edge(
                          record["source"], record["target"], label=record["type"]
                      )
                  # åœ¨ Streamlit æ‡‰ç”¨ä¸­æ¸²æŸ“è¦–è¦ºåŒ–åœ–å½¢
                  st.graphviz_chart(graph_object)


  # æä¾›ç”¨æˆ¶è¼¸å…¥ç•Œé¢
  user_input = st.chat_input("Who is the CEO of Neo4j?")

  if user_input:
      # é¡¯ç¤ºè¼‰å…¥å‹•ç•«
      with st.spinner("Processing"):
          # ç”Ÿæˆå°è©±ä¸Šä¸‹æ–‡
          context = generate_context(user_input)
          # åŸ·è¡Œåœ–å½¢æœç´¢å’Œèªè¨€æ¨¡å‹è™•ç†
          output = graph_search({"query": user_input, "chat_history": context})

          # å„²å­˜çµæœåˆ°session state
          st.session_state.user_input.append(user_input)
          st.session_state.generated.append(output["result"])
          st.session_state.viz_data.append(output["viz_data"])
          st.session_state.database.append(output["database"])
          st.session_state.cypher.append(output["cypher"])

  # å±•ç¤ºç”Ÿæˆçš„å°è©±
  if st.session_state["generated"]:
      size = len(st.session_state["generated"])
      for i in range(max(size - 3, 0), size):
          dynamic_response_tabs(i)
  ```

<br>

## å…¶ä»–æ–‡ä»¶

1. å°å…¥è‡ªè¨‚æ¨¡çµ„ `cypher_chain.py`ã€‚

  ```python
  # cypher_chain.py
  import os

  from typing import Any, Dict, List, Optional, Tuple
  from langchain.chains.graph_qa.cypher import extract_cypher
  from langchain.chains.openai_functions import create_structured_output_chain
  from langchain.schema import SystemMessage
  from langchain.prompts import ChatPromptTemplate, PromptTemplate

  from langchain.chains import GraphCypherQAChain
  from langchain.callbacks.manager import CallbackManagerForChainRun

  try:
      from pydantic.v1.main import BaseModel, Field
  except ImportError:
      from pydantic.main import BaseModel, Field

  from cypher_validator import CypherQueryCorrector, Schema


  def remove_entities(doc):
      """
      Replace named entities in the given text with their corresponding entity labels.

      Parameters:
      - doc (Spacy Document): processed SpaCy document of the input text.

      Returns:
      - str: The modified text with named entities replaced by their entity labels.

      Example:
      >>> replace_entities_with_labels("Apple is looking at buying U.K. startup for $1 billion.")
      'ORG is looking at buying GPE startup for MONEY .'
      """
      # Initialize an empty list to store the new tokens
      new_tokens = []
      # Keep track of the end index of the last entity
      last_end = 0

      # Iterate through entities, replacing them with their entity label
      for ent in doc.ents:
          # Add the tokens that come before this entity
          new_tokens.extend([token.text for token in doc[last_end : ent.start]])
          # Replace the entity with its label
          new_tokens.append(f"{ent.label_}")
          # Update the last entity end index
          last_end = ent.end

      # Add any remaining tokens after the last entity
      new_tokens.extend([token.text for token in doc[last_end:]])
      # Join the new tokens into a single string
      new_text = " ".join(new_tokens)
      return new_text


  AVAILABLE_RELATIONSHIPS = [
      Schema("Person", "HAS_PARENT", "Person"),
      Schema("Person", "HAS_CHILD", "Person"),
      Schema("Organization", "HAS_SUPPLIER", "Organization"),
      Schema("Organization", "IN_CITY", "City"),
      Schema("Organization", "HAS_CATEGORY", "IndustryCategory"),
      Schema("Organization", "HAS_CEO", "Person"),
      Schema("Organization", "HAS_SUBSIDIARY", "Organization"),
      Schema("Organization", "HAS_COMPETITOR", "Organization"),
      Schema("Organization", "HAS_BOARD_MEMBER", "Person"),
      Schema("Organization", "HAS_INVESTOR", "Organization"),
      Schema("Organization", "HAS_INVESTOR", "Person"),
      Schema("City", "IN_COUNTRY", "Country"),
      Schema("Article", "HAS_CHUNK", "Chunk"),
      Schema("Article", "MENTIONS", "Organization")
  ]

  CYPHER_SYSTEM_TEMPLATE = """
  Purpose:
  Your role is to convert user questions concerning data in a Neo4j database into accurate Cypher queries.
  """

  cypher_query_corrector = CypherQueryCorrector(AVAILABLE_RELATIONSHIPS)

  CYPHER_QA_TEMPLATE = """You are an assistant that helps to form nice and human understandable answers.
  The information part contains the provided information that you must use to construct an answer.
  The provided information is authoritative, you must never doubt it or try to use your internal knowledge to correct it.
  Make the answer sound as a response to the question. Do not mention that you based the result on the given information.
  If the provided information is empty, say that you don't know the answer.
  Even if the question doesn't provide full person or organization names, you should use the full names from the provided
  information to construct an answer.
  Information:
  {context}

  Question: {question}
  Helpful Answer:"""
  CYPHER_QA_PROMPT = PromptTemplate(
      input_variables=["context", "question"], template=CYPHER_QA_TEMPLATE
  )


  class Entities(BaseModel):
      """Identifying information about entities."""

      name: List[str] = Field(
          ...,
          description="All the person, organization, or business entities that appear in the text",
      )


  class CustomCypherChain(GraphCypherQAChain):
      def process_entities(self, text: str) -> List[str]:
          prompt = ChatPromptTemplate.from_messages(
              [
                  (
                      "system",
                      "You are extracting organization and person entities from the text.",
                  ),
                  (
                      "human",
                      "Use the given format to extract information from the following input: {input}",
                  ),
              ]
          )

          entity_chain = create_structured_output_chain(
              Entities, self.qa_chain.llm, prompt
          )
          entities = entity_chain.run(text)
          print(entities)
          return entities.name

      def get_viz_data(self, entities: List[str]) -> List[Tuple[str, str]]:
          viz_query = """
          MATCH (n:Person|Organization) WHERE n.name IN $entities
          CALL {
              WITH n
              MATCH (n)-[r:!MENTIONS]->(m)
              WHERE m.name IS NOT NULL
              RETURN n.name AS source, type(r) AS type, m.name AS target
              LIMIT 5
              UNION
              WITH n
              MATCH (n)<-[r:!MENTIONS]-(m)
              WHERE m.name IS NOT NULL
              RETURN n.name AS target, type(r) AS type, m.name AS source
              LIMIT 5
          }
          RETURN source, type, target LIMIT 20
          """
          results = self.graph.query(viz_query, {"entities": entities})
          return results

      def find_entity_match(self, entity: str, k: int = 3) -> List[str]:
          fts_query = """
          CALL db.index.fulltext.queryNodes('entity', $entity + "*", {limit:$k})
          YIELD node,score
          RETURN node.name AS result
          """

          return [
              el["result"]
              for el in self.graph.query(
                  fts_query, {"entity": "AND ".join(entity.split()), "k": k}
              )
          ]

      def generate_system_message(
          self, relevant_entities: str = "", fewshot_examples: str = ""
      ) -> SystemMessage:
          system_message = CYPHER_SYSTEM_TEMPLATE
          system_message += (
              f"Database Schema: Please refer to the provided database schema {self.graph_schema} for reference. "
              "Guidelines: Relationships & Properties: Utilize only the relationship types "
              "and properties specified in the provided schema. Do not introduce new ones.\n"
          )
          if relevant_entities:
              system_message += (
                  f"Entity Substitution: If the question mentions specific entities, replace them in the query with corresponding entities from "
                  f"the given list. Given list of entities is: {relevant_entities}\n"
                  "Example: If the list contains John: ['John Goodman'], replace 'John' in the query with 'John Goodman'."
                  "Flexible Queries: Ensure your Cypher queries can capture all relevant entities.\n"
                  "Correct: MATCH (p:Person) WHERE p.name IN ['John Goodman', 'John Stockton'] MATCH (p)<-[:BOARD_MEMBER]-(o:Organization)"
              )
          if fewshot_examples:
              system_message += (
                  f"Example Queries: Please refer to the provided example queries for constructing Cypher statements:\n"
                  f"{fewshot_examples}\n"
              )

          system_message += (
              "Informative Responses: Ensure your responses contain sufficient information to answer the question for anyone lacking context.\n"
              "Include details about both persons and organizations, if applicable. \n"
              "Text Search: To search text, avoid using the CONTAINS clause. "
              "Instead, employ apoc.ml.openai.embedding and gds.similarity.cosine functions or db.index.vector.queryNodes.\n"
              "Note: If you use apoc.ml.openai.embedding, it must be the first operation in your query.\n"
              "Result Chunking: When returning text, always provide exactly three chunksâ€”no more, no less.\n"
              "By following these guidelines, you'll ensure the generated Cypher queries accurately reflect the database entities and relationships."
              "Solve it step by step."
          )
          return SystemMessage(content=system_message)

      def get_fewshot_examples(self, question):
          results = self.graph.query(
              """
          CALL apoc.ml.openai.embedding([$question], $openai_api_key)
                                      YIELD embedding                             
          CALL db.index.vector.queryNodes('fewshot', 3, embedding)
                                      YIELD node, score
          RETURN node.Question AS question, node.Cypher as cypher
                                      """,
              {"question": question, "openai_api_key": os.environ["OPENAI_API_KEY"]},
          )

          fewshot = "\n".join([f"#{el['question']}\n{el['cypher']}" for el in results])
          print("-" * 30)
          print(fewshot)
          return fewshot

      def _call(
          self,
          inputs: Dict[str, Any],
          run_manager: Optional[CallbackManagerForChainRun] = None,
      ) -> Dict[str, Any]:

          _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()
          callbacks = _run_manager.get_child()
          question = inputs[self.input_key]
          chat_history = inputs["chat_history"]
          # Extract mentioned people and organizations and match them to database values
          entities = self.process_entities(question)
          print(f"NER found: {entities}")
          relevant_entities = dict()
          for entity in entities:
              relevant_entities[entity] = self.find_entity_match(entity)
          print(f"Relevant entities are: {relevant_entities}")

          # Get few-shot examples using vector search
          fewshots = self.get_fewshot_examples(question)

          system = self.generate_system_message(str(relevant_entities), fewshots)
          generated_cypher = self.cypher_generation_chain.llm.predict_messages(
              [system] + chat_history
          )
          print(generated_cypher.content)
          generated_cypher = extract_cypher(generated_cypher.content)
          validated_cypher = cypher_query_corrector(
              generated_cypher
          )
          print(validated_cypher)
          # If Cypher statement wasn't generated
          # Usually happens when LLM decides it can't answer
          if not "RETURN" in validated_cypher:
              chain_result: Dict[str, Any] = {
                  self.output_key: validated_cypher,
                  "viz_data": (None, None),
                  "database": None,
                  "cypher": None,
              }
              return chain_result

          # Retrieve and limit the number of results
          context = self.graph.query(
              validated_cypher, {"openai_api_key": os.environ["OPENAI_API_KEY"]}
          )[: self.top_k]

          result = self.qa_chain(
              {"question": question, "context": context}, callbacks=callbacks
          )
          final_result = result[self.qa_chain.output_key]

          final_entities = self.process_entities(final_result)
          if final_entities:
              viz_data = self.get_viz_data(final_entities)
          else:
              viz_data = None

          chain_result: Dict[str, Any] = {
              self.output_key: final_result,
              "viz_data": (viz_data, final_entities),
              "database": context,
              "cypher": validated_cypher,
          }
          return chain_result
  ```

<br>

2. å°å…¥è‡ªè¨‚æ¨¡çµ„ `cypher_validator.py`ã€‚

  ```python
  # cypher_validator.py
  import re
  from collections import namedtuple
  from typing import Any, Dict, List, Optional, Tuple

  Schema = namedtuple("Schema", ["left_node", "relation", "right_node"])


  class CypherQueryCorrector:
      """
      Used to correct relationship direction in generated Cypher statements.
      This code is copied from the winner's submission to the Cypher competition:
      https://github.com/sakusaku-rich/cypher-direction-competition
      """

      property_pattern = re.compile(r"\{.+?\}")
      node_pattern = re.compile(r"\(.+?\)")
      path_pattern = re.compile(r"\(.*\).*-.*-.*\(.*\)")
      node_relation_node_pattern = re.compile(
          r"(\()+(?P<left_node>[^()]*?)\)(?P<relation>.*?)\((?P<right_node>[^()]*?)(\))+"
      )
      relation_type_pattern = re.compile(r":(?P<relation_type>.+?)?(\{.+\})?]")

      def __init__(self, schemas: List[Schema]):
          """
          Args:
              schemas: list of schemas
          """
          self.schemas = schemas

      def clean_node(self, node: str) -> str:
          """
          Args:
              node: node in string format
          """
          node = re.sub(self.property_pattern, "", node)
          node = node.replace("(", "")
          node = node.replace(")", "")
          node = node.strip()
          return node

      def detect_node_variables(self, query: str) -> Dict[str, List[str]]:
          """
          Args:
              query: cypher query
          """
          nodes = re.findall(self.node_pattern, query)
          nodes = [self.clean_node(node) for node in nodes]
          res: Dict[str, Any] = {}
          for node in nodes:
              parts = node.split(":")
              if parts == "":
                  continue
              variable = parts[0]
              if variable not in res:
                  res[variable] = []
              res[variable] += parts[1:]
          return res

      def extract_paths(self, query: str) -> "List[str]":
          """
          Args:
              query: cypher query
          """
          return re.findall(self.path_pattern, query)

      def judge_direction(self, relation: str) -> str:
          """
          Args:
              relation: relation in string format
          """
          direction = "BIDIRECTIONAL"
          if relation[0] == "<":
              direction = "INCOMING"
          if relation[-1] == ">":
              direction = "OUTGOING"
          return direction

      def extract_node_variable(self, part: str) -> Optional[str]:
          """
          Args:
              part: node in string format
          """
          part = part.lstrip("(").rstrip(")")
          idx = part.find(":")
          if idx != -1:
              part = part[:idx]
          return None if part == "" else part

      def detect_labels(
          self, str_node: str, node_variable_dict: Dict[str, Any]
      ) -> List[str]:
          """
          Args:
              str_node: node in string format
              node_variable_dict: dictionary of node variables
          """
          splitted_node = str_node.split(":")
          variable = splitted_node[0]
          labels = []
          if variable in node_variable_dict:
              labels = node_variable_dict[variable]
          elif variable == "" and len(splitted_node) > 1:
              labels = splitted_node[1:]
          return labels

      def verify_schema(
          self,
          from_node_labels: List[str],
          relation_types: List[str],
          to_node_labels: List[str],
      ) -> bool:
          """
          Args:
              from_node_labels: labels of the from node
              relation_type: type of the relation
              to_node_labels: labels of the to node
          """
          valid_schemas = self.schemas
          if from_node_labels != []:
              from_node_labels = [label.strip("`") for label in from_node_labels]
              valid_schemas = [
                  schema for schema in valid_schemas if schema[0] in from_node_labels
              ]
          if to_node_labels != []:
              to_node_labels = [label.strip("`") for label in to_node_labels]
              valid_schemas = [
                  schema for schema in valid_schemas if schema[2] in to_node_labels
              ]
          if relation_types != []:
              relation_types = [type.strip("`") for type in relation_types]
              valid_schemas = [
                  schema for schema in valid_schemas if schema[1] in relation_types
              ]
          return valid_schemas != []

      def detect_relation_types(self, str_relation: str) -> Tuple[str, List[str]]:
          """
          Args:
              str_relation: relation in string format
          """
          relation_direction = self.judge_direction(str_relation)
          relation_type = self.relation_type_pattern.search(str_relation)
          if relation_type is None or relation_type.group("relation_type") is None:
              return relation_direction, []
          relation_types = [
              t.strip().strip("!")
              for t in relation_type.group("relation_type").split("|")
          ]
          return relation_direction, relation_types

      def correct_query(self, query: str) -> str:
          """
          Args:
              query: cypher query
          """
          node_variable_dict = self.detect_node_variables(query)
          paths = self.extract_paths(query)
          for path in paths:
              original_path = path
              start_idx = 0
              while start_idx < len(path):
                  match_res = re.match(self.node_relation_node_pattern, path[start_idx:])
                  if match_res is None:
                      break
                  start_idx += match_res.start()
                  match_dict = match_res.groupdict()
                  left_node_labels = self.detect_labels(
                      match_dict["left_node"], node_variable_dict
                  )
                  right_node_labels = self.detect_labels(
                      match_dict["right_node"], node_variable_dict
                  )
                  end_idx = (
                      start_idx
                      + 4
                      + len(match_dict["left_node"])
                      + len(match_dict["relation"])
                      + len(match_dict["right_node"])
                  )
                  original_partial_path = original_path[start_idx : end_idx + 1]
                  relation_direction, relation_types = self.detect_relation_types(
                      match_dict["relation"]
                  )

                  if relation_types != [] and "".join(relation_types).find("*") != -1:
                      start_idx += (
                          len(match_dict["left_node"]) + len(match_dict["relation"]) + 2
                      )
                      continue

                  if relation_direction == "OUTGOING":
                      is_legal = self.verify_schema(
                          left_node_labels, relation_types, right_node_labels
                      )
                      if not is_legal:
                          is_legal = self.verify_schema(
                              right_node_labels, relation_types, left_node_labels
                          )
                          if is_legal:
                              corrected_relation = "<" + match_dict["relation"][:-1]
                              corrected_partial_path = original_partial_path.replace(
                                  match_dict["relation"], corrected_relation
                              )
                              query = query.replace(
                                  original_partial_path, corrected_partial_path
                              )
                          else:
                              return ""
                  elif relation_direction == "INCOMING":
                      is_legal = self.verify_schema(
                          right_node_labels, relation_types, left_node_labels
                      )
                      if not is_legal:
                          is_legal = self.verify_schema(
                              left_node_labels, relation_types, right_node_labels
                          )
                          if is_legal:
                              corrected_relation = match_dict["relation"][1:] + ">"
                              corrected_partial_path = original_partial_path.replace(
                                  match_dict["relation"], corrected_relation
                              )
                              query = query.replace(
                                  original_partial_path, corrected_partial_path
                              )
                          else:
                              return ""
                  else:
                      is_legal = self.verify_schema(
                          left_node_labels, relation_types, right_node_labels
                      )
                      is_legal |= self.verify_schema(
                          right_node_labels, relation_types, left_node_labels
                      )
                      if not is_legal:
                          return ""

                  start_idx += (
                      len(match_dict["left_node"]) + len(match_dict["relation"]) + 2
                  )
          return query

      def __call__(self, query: str) -> str:
          """Correct the query to make it valid. If
          Args:
              query: cypher query
          """
          return self.correct_query(query)
  ```

<br>

_é€™å€‹å°ˆæ¡ˆç›®å‰é›–å¯é‹è¡Œä½†ä¸ç®—å®Œç¾ï¼Œå¦ä½œä¿®æ”¹_

___

_END_

